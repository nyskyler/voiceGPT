{% extends "base2.html" %}
{% block content %}
<link href="https://hangeul.pstatic.net/hangeul_static/css/maru-buri.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-gothic.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-gothic-coding.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-gothic-eco.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-myeongjo.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-myeongjo-eco.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/NanumMyeongjoYetHangul.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-barun-gothic.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/NanumBarunGothicYetHangul.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-barun-pen.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-brush.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-pen.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-square.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-square-neo.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/nanum-square-round.css" rel="stylesheet">
<link href="https://hangeul.pstatic.net/hangeul_static/css/NanumHuman.css" rel="stylesheet">
<style>
  #myRow {
    display: flex;
    flex-direction: row;
  }
  #sidebar {
    display: flex;
    flex-direction: column;
    height: 95vh;
    border-right: 1px solid black;
    transform: translateX(0); /* 기본 위치 */
    transition: transform 0.5s ease, width 0.5s ease; /* 슬라이드 애니메이션 */
  }
  .sideItem {
    height: 87vh;
    /* flex: 1; */
    /* padding: 0.1rem; */
    overflow-y: auto;
  }
  .chat-window {
    display: flex;
    flex-direction: column;
    flex: auto;
    height: 95vh;
    transition: flex 0.5s ease; /* 슬라이드 애니메이션 */
  }
  .sidebar-hidden {
    transform: translateX(-100%);
    transition: transform 0.5s ease, width 0.5s ease;
    width: 0%;
    padding: 0px;
  }
  .chat-expanded {
    flex-grow: 1; /* 부모 너비를 기준으로 남은 공간 채우기 */
    transition: flex-grow 0.5s ease;
  }
  .invisible {
    width: 0%;
    display: none;
  }
  .thumbnails {
    display: flex;
    /* flex-direction: row; */
    /* flex-wrap: wrap; */
    overflow-x: scroll;
    white-space: nowrap; /* 줄바꿈 방지 */
  }
  /* 스크롤바 스타일링 (웹킷 브라우저용) */
  .thumbnails::-webkit-scrollbar {
    height: 8px; /* 스크롤바 높이 */
  }

  .thumbnails::-webkit-scrollbar-thumb {
    background-color: #888; /* 스크롤바 색상 */
    border-radius: 4px; /* 스크롤바 모서리 둥글게 */
  }

  .thumbnails::-webkit-scrollbar-thumb:hover {
    background-color: #555; /* 스크롤바 색상 (호버 시) */
  }
  .banner {
    flex: 0 0 auto;
    padding-top: 0.9rem;
    padding-bottom: 0.5rem;
  }
  .sideBanner {
    flex: 0 0 auto;
    padding-top: 0.6rem;
    padding-bottom: 0.6rem;
  }
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding: 0 10px;
  }
  .modeChange {
    display: none;
  }
  .cursor-pointer {
    cursor: pointer; /* 포인터 모양으로 변경 */
  }
  .messages {
    flex: auto;
    padding: 1rem;
    overflow-y: auto;
  }
  .input-area {
    padding: 0rem 1rem 0.6rem 1rem;
  }
  .input-group {
    display: flex;
    align-items: center;
    /* border: 1px solid #ccc; */
    border-radius: 5px;
    padding: 5px;
    width: 100%;
  }
  #myInput {
    flex-grow: 1;
    border: none;
    border-radius: 5px;
    outline: none;
    resize: none;
    max-height: 300px;
    overflow-y: auto;
  }
  #myInput:focus, #systemInput:focus {
    outline: none;
    box-shadow: none;
    border-color: black;
  }
  .attach-icon {
    margin-left: 3px;
    margin-right: 10px;
    cursor: pointer;
  }
  #myBtn {
    background-color: transparent;
    border: none;
    cursor: pointer;
  }

  #myBtn i {
    color: #007bff;
    font-size: 1.5em;
  }

  #myBtn:hover i {
    color: #0056b3;
  }
  p {
    margin-bottom: 0;
  }
  .card-body {
    position: relative;
  }
  .card {
    border: 1px solid;
    border-radius: 2px;
  }
  .delete_message {
    position: absolute;
    bottom: 10px;
    right: 10px;
    display: none; /* 기본적으로 보이지 않게 설정 */
    width: 5px; /* 버튼 크기 조정 */
    height: 5px; /* 버튼 크기 조정 */
  }
  .card-body:hover .delete_message {
    display: block; /* hover 시에만 버튼 보이기 */
  }
  .imgContainer, .imgCard {
    margin: 5px;
  }
  .imgContainer:hover .delete_message {
    top: 10px;
    right: 10px;
    display: block; /* hover 시에만 버튼 보이기 */
  }

  /* Toggle Button */
  .toggle-btn {
    border: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    outline: none;
    margin-right: 0.3rem;
  }
  .toggle-btn i {
    font-size: 1.2rem;
  }
  .btn-margin {
    margin-left: 0.8rem;
  }
  #searchInput:focus, #searchInput2:focus, #topicInput:focus {
    outline: none;
    box-shadow: none;
    border-color: black;
  }
  #article {
    font-family: 'inherit';
  }
  .btn-transparent {
    background-color: transparent;
    border: none;
  }
  .btn-transparent:hover {
    background-color: rgba(0, 0, 0, 0.1); /* 호버 시 배경색 추가 (선택 사항) */
  }
  .bg-3030 {
    background-color: #303030 !important;
  }
  .list-group-item-dark {
    background-color: #212121 !important;
    color: #fff; /* 필요시 텍스트 색상 */
    border: none !important;
  }
  .list-group-item-dark.active, .list-group-item-dark:hover {
    background-color: #303030 !important;
    border-radius: 1rem !important;
    color: #fff; /* 필요시 텍스트 색상 */
  }
  ul.gpt_ul {
    font-size: 0.8rem;
  }
  /* 코드 블록 스타일 */
  pre code {
    display: block;
    padding: 1rem;
    border-radius: 0.5rem;
    background-color: #1e1e1e; /* VSCode 다크 모드 배경 */
    color: #dcdcdc; /* 기본 폰트 색상 */
    font-family: 'Fira Code', 'Consolas', 'Courier New', monospace;
    font-size: 0.9rem;
    overflow-x: auto;
  }

  /* 줄 번호 스타일 */
  .hljs-ln-numbers {
    text-align: right;
    color: #888;
    border-right: 1px solid #444;
    vertical-align: top;
    padding-right: 10px;
    user-select: none;
  }

  .hljs-ln-code {
    padding-left: 10px;
  }

  .markDown > p:not(:last-child) {
    white-space: pre-line;  /* \n → 줄바꿈으로 보존 */
    margin-bottom: 1rem;    /* 마지막 p를 제외하고만 여백 적용 */
  }

  @media (min-width: 1024px) and (max-width: 1366px) {
  /* 아이패드 프로 12.9인치 화면에만 적용할 스타일 */
    #sidebar {
      height: 94vh;
    }
    .sideItem {
      height: 86vh;
    }
    .chat-window {
      height: 94vh;
    }
    .input-area {
      padding-right: 1rem;
    }
  } 

  @media (max-width: 767.98px) and (orientation: portrait) {
    .chat-window {
      height: 80vh; /* 모바일에서는 전체 화면 높이로 설정 */
    }
    .toggle-btn {
      display: none;
    }
    #fontIncrease, #fontDecrease {
      display: none;
    }
    .input-area {
      padding-right: 1rem;
    }
  }
</style>
<!-- 오프캔버스 사이드바 -->
<div class="offcanvas offcanvas-start" tabindex="-1" id="offcanvasSidebar" aria-labelledby="offcanvasSidebarLabel">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title" id="offcanvasSidebarLabel"></h5>
    <button type="button" style="margin-right: 1rem;" class="btn-close text-reset" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    <button id="chatBtn2" class="btn btn-light chatBtn" style="padding: 0.5rem; margin-right: 0.8rem;"><i class="fa-regular fa-pen-to-square"></i></button>
    <form id="searchForm2" style="display: flex; align-items: center;">
      <div class="input-group" style="display: flex; align-items: center; border: none; outline: none;">
        <input type="text" style="border: 1px solid black; border-right: 0; border-radius: 4px 0 0 4px;" maxlength="12" id="searchInput2" name="serachInput" class="form-control" aria-label="Message" aria-describedby="send-button" autocomplete="off" rows="1">
        <button id="searchBtn2" class="btn btn-light" style="margin-left: 0; border: 1px solid black; border-left: 0; border-radius: 0 4px 4px 0;" type="submit">
          <i class="fa-solid fa-magnifying-glass"></i>
        </button>
      </div>
    </form>
  </div>
  <div class="offcanvas-body p-0">
    <ul class="list-group list-group-flush toc gpt_ul">
    </ul>
  </div>
</div>
<div class="container-fluid">
  <div id="myRow" class="row">
    <div id="sidebar" class="col-12 col-md-3 col-xl-2 sidebar d-none d-md-block">
      <div class="sideBanner" style="display: flex; align-items: center;">
        <button id="chatBtn" class="btn btn-transparent chatBtn" style="padding: 0.5rem; margin-right: 0.8rem;"><i class="fa-regular fa-pen-to-square"></i></button>
        <form id="searchForm" style="display: flex; align-items: center;">
          <div class="input-group" style="display: flex; align-items: center; border: none; outline: none;">
            <input type="text" style="border: 1px solid black; border-right: 0; border-radius: 4px 0 0 4px;" maxlength="12" id="searchInput" name="serachInput" class="form-control" aria-label="Message" aria-describedby="send-button" autocomplete="off" rows="1">
            <button id="searchBtn" class="btn btn-light" style="margin-left: 0; border: 1px solid black; border-left: 0; border-radius: 0 4px 4px 0;" type="submit">
              <i class="fa-solid fa-magnifying-glass"></i>
            </button>
          </div>
        </form>
      </div>
      <ul class="list-group list-group-flush toc gpt_ul">
      </ul>
    </div>
    <div id="chatWindow" class="col-12 col-md-9 col-xl-10 chat-window p-0">
      <div class="banner">
        <div class="header">
          <span>
            <button id="toggleButton" class="toggle-btn btn btn-transparent">
              <i class="fa-regular fa-square-caret-left"></i><!-- FontAwesome icon -->
            </button>
            <span id="currentModel" class="fs-5"></span>
          </span>
          <span>
            <button id="fontIncrease" class="btn btn-transparent"><i class="fa-regular fa-square-plus"></i></button>
            <button id="fontDecrease" class="btn btn-transparent"><i class="fa-regular fa-square-minus"></i></button>
            <button id="paletteBtn" class="btn btn-transparent"><i class="fa-solid fa-palette"></i></i></button>
            <button id="settingBtn" class="btn btn-transparent"><i class="fa-solid fa-gear"></i></button>
            <button id="dalleSettingBtn" class="btn btn-transparent modeChange"><i class="fa-solid fa-gears"></i></button>
            <button id="deleteBtn" class="btn btn-transparent"><i class="fa-regular fa-trash-can"></i></button>
            <!-- 모바일에서 오프캔버스를 여는 버튼 -->
            <div class="d-md-none p-1" style="display: inline;">
              <button class="btn btn-primary" type="button" data-bs-toggle="offcanvas" data-bs-target="#offcanvasSidebar" aria-controls="offcanvasSidebar">
                <i class="fa-brands fa-stack-exchange"></i>
              </button>
            </div>
          </span>
        </div>
      </div>
      <div class="messages">
        <div id="article"></div>
        <div id="mySpinner" class="spinner-grow text-dark" role="status" style="display:none;">
          <span class="visually-hidden">Loading...</span>
        </div>
      </div>
      <!-- 새로 채팅창을 시작할 때 주제를 입력받는 모달창 -->
      <button type="button" id="modalBtn" style="display: none;" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#exampleModal" data-bs-whatever="{{ g.user.username }}"></button>
      <div class="modal fade" id="exampleModal" tabindex="-1" aria-labelledby="exampleModalLabel">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h1 class="modal-title fs-5" id="exampleModalLabel"></h1>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <form id="modalForm">
                <div class="mb-3">
                  <label for="chatTopic" class="col-form-label">채팅 주제</label>
                  <input type="text" class="form-control" id="chatTopic" minlength="2" maxlength="30" placeholder="주제를 30자 이내로 입력" autocomplete="off">
                </div>
              </form>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
              <button type="submit" class="btn btn-primary" form="modalForm">정하기</button>
            </div>
          </div>
        </div>
      </div>
      <!-- 특정 주제에 대한 GPT 역할을 지정할 때 사용하는 모달창 -->
      <button type="button" id="systemBtn" style="display: none;" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#systemModal" data-bs-whatever="{{ g.user.username }}"></button>
      <div class="modal fade" id="systemModal" tabindex="-1" aria-labelledby="systemModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h1 class="modal-title fs-5" id="systemModalLabel"></h1>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <form id="systemForm">
                <p class="fs-6"><i class="fa-regular fa-square-check"></i>&nbsp;&nbsp;GPT 모델</p>
                <div id="models" class="mb-3" style="display: flex; justify-content: space-evenly;">
                </div>
                <label for="memoryRange" class="form-label"><i class="fa-regular fa-comment-dots"></i>&nbsp;&nbsp;기억하는 최근 문답의 수(0~5)</label>
                <input type="range" class="form-range" min="0" max="5" step="1" id="memoryRange" value="1">
                <p class="mt-3 fs-6"><i class="fa-regular fa-image"></i>&nbsp;&nbsp;이미지 해상도</p>
                <div class="mb-3" style="display: flex; justify-content: space-evenly;">
                  <input type="radio" class="btn-check" name="resolution" id="resolution1" autocomplete="off">
                  <label class="btn" for="resolution1">512</label>
                  <input type="radio" class="btn-check" name="resolution" id="resolution2" autocomplete="off">
                  <label class="btn" for="resolution2">1024</label>
                  <input type="radio" class="btn-check" name="resolution" id="resolution3" autocomplete="off">
                  <label class="btn" for="resolution3">2048</label>
                </div>
                <div class="mb-3">
                  <label for="topicInput" class="col-form-label"><i class="fa-solid fa-t"></i>&nbsp;&nbsp;대화 주제</label>
                  <input maxlength="100" id="topicInput" name="topic" class="form-control" aria-label="Message" aria-describedby="send-button" autocomplete="off""></input> 
                </div>
                <div class="mb-3">
                  <label for="systemInput" class="col-form-label"><i class="fa-regular fa-keyboard"></i>&nbsp;&nbsp;GPT 역할</label>
                  <textarea maxlength="1500" id="systemInput" name="message" class="form-control" placeholder="1500자 이내로 입력" aria-label="Message" aria-describedby="send-button" autocomplete="off" rows="5" style="resize: none; overflow-y: auto;"></textarea> 
                </div>
              </form>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
              <button type="submit" class="btn btn-primary" form="systemForm">정하기</button>
            </div>
          </div>
        </div>
      </div>
      <!-- DALL-E API 설정을 지정할 때 사용하는 모달창 -->
      <button type="button" id="dalleBtn" style="display: none;" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#dalleModal" data-bs-whatever="{{ g.user.username }}"></button>
      <div class="modal fade" id="dalleModal" tabindex="-1" aria-labelledby="dalleModalLabel" aria-hidden="true">   
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h1 class="modal-title fs-5" id="dalleModalLabel"></h1>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <form id="dalleForm">
                <p class="fs-6"><i class="fa-regular fa-square-check"></i>&nbsp;&nbsp;DALL-E 모델</p>
                <div id="imageModelSelection" class="mb-3" style="display: flex; justify-content: space-evenly;">
                </div>
                <label for="numberRange" class="form-label"><i class="fa-solid fa-n"></i>&nbsp;&nbsp;생성되는 이미지의 개수(1~10)</label>
                <input type="range" class="form-range" min="1" max="10" step="1" id="numberRange" value="1">
                <p class="mt-3 fs-6"><i class="fa-regular fa-image"></i>&nbsp;&nbsp;품질</p>
                <div class="mb-3" style="display: flex; justify-content: space-evenly;">
                  <input type="radio" class="btn-check" name="quality" id="quality1" autocomplete="off">
                  <label class="btn" for="quality1">standard</label>
                  <input type="radio" class="btn-check" name="quality" id="quality2" autocomplete="off">
                  <label class="btn" for="quality2">hd</label>
                </div>
                <label for="dalleSize" class="form-label mt-3"><i class="fa-solid fa-expand"></i>&nbsp;&nbsp;크기</label>
                <select id="dalleSize" class="form-select form-select-sm">
                  <option value="256x256">256x256</option>
                  <option value="512x512">512x512</option>
                  <option value="1024x1024">1024x1024</option>
                  <option value="1792x1024">1792x1024</option>
                  <option value="1024x1792">1024x1792</option>
                </select>
                <p class="mt-4 fs-6"><i class="fa-solid fa-pen-fancy"></i>&nbsp;&nbsp;스타일</p>
                <div class="mb-3" style="display: flex; justify-content: space-evenly;">
                  <input type="radio" class="btn-check" name="dalleStyle" id="style1" autocomplete="off">
                  <label class="btn" for="style1">vivid</label>
                  <input type="radio" class="btn-check" name="dalleStyle" id="style2" autocomplete="off">
                  <label class="btn" for="style2">natural</label>
                </div>
              </form>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
              <button type="submit" class="btn btn-primary" form="dalleForm">정하기</button>
            </div>
          </div>
        </div>
      </div>
      <!-- 글꼴 및 배경 디자인을 변경할 때 사용하는 모달창 -->
      <button type="button" id="designBtn" style="display: none;" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#paletteModal" data-bs-whatever="{{ g.user.username }}"></button>
      <div class="modal fade" id="paletteModal" tabindex="-1" aria-labelledby="paletteModalLabel" aria-hidden="true">
        <div class="modal-dialog">
          <div class="modal-content">
            <div class="modal-header">
              <h1 class="modal-title fs-5" id="paletteModalLabel"></h1>
              <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
            </div>
            <div class="modal-body">
              <form id="paletteForm">
                <label for="fontSelect" class="form-label"><i class="fa-solid fa-font"></i>&nbsp;&nbsp;글꼴</label>
                <select id="fontSelect" class="form-select form-select-sm mb-2" aria-label="Large select example">
                  <option value="inherit">시스템 글꼴</option>
                  <option value="MaruBuriExtraLight">마루부리 아주 가는</option>
                  <option value="MaruBuriLight">마루부리 가는</option>
                  <option value="MaruBuri">마루부리</option>
                  <option value="MaruBuriBold">마루부리 굵은</option>
                  <option value="MaruBuriSemiBold">마루부리 조금 굵은</option>
                  <option value="NanumGothicLight">나눔고딕 가는</option>
                  <option value="NanumGothic">나눔고딕 중간</option>
                  <option value="NanumGothicBold">나눔고딕 굵은</option>
                  <option value="NanumGothicExtraBold">나눔고딕 아주 굵은</option>
                  <option value="NanumGothicCodingLigature">나눔고딕 D2coding ligature</option>
                  <option value="NanumGothicCodingLigatureBold">나눔고딕 D2coding ligatureBold</option>
                  <option value="NanumGothicCoding">나눔고딕 D2coding 중간</option>
                  <option value="NanumGothicCodingBold">나눔고딕 D2coding 굵은</option>
                  <option value="NanumGothicEco">나눔고딕에코 중간</option>
                  <option value="NanumGothicEcoBold">나눔고딕에코 굵은</option>
                  <option value="NanumGothicEcoExtraBold">나눔고딕에코 아주 굵은</option>
                  <option value="NanumMyeongjo">나눔명조 중간</option>
                  <option value="NanumMyeongjoBold">나눔명조 굵은</option>
                  <option value="NanumMyeongjoExtraBold">나눔명조 아주 굵은</option>
                  <option value="NanumMyeongjoEco">나눔명조에코 중간</option>
                  <option value="NanumMyeongjoEcoBold">나눔명조에코 굵은</option>
                  <option value="NanumMyeongjoEcoExtraBold">나눔명조에코 아주 굵은</option>
                  <option value="NanumMyeongjoYetHangul">나눔명조옛한글</option>
                  <option value="NanumBarunGothicUltraLight">나눔바른고딕 아주 가는</option>
                  <option value="NanumBarunGothicLight">나눔바른고딕 가는</option>
                  <option value="NanumBarunGothic">나눔바른고딕 중간</option>
                  <option value="NanumBarunGothicBold">나눔바른고딕 굵은</option>
                  <option value="NanumBarunGothicYetHangul">나눔바른고딕옛한글</option>
                  <option value="NanumBarunPen">나눔바른펜 일반용 중간</option>
                  <option value="NanumBarunPenBold">나눔바른펜 일반용 굵은</option>
                  <option value="NanumBrush">나눔손글씨 붓</option>
                  <option value="NanumPen">나눔손글씨 펜</option>
                  <option value="NanumSquareLight">나눔스퀘어 가는</option>
                  <option value="NanumSquare">나눔스퀘어 중간</option>
                  <option value="NanumSquareBold">나눔스퀘어 굵은</option>
                  <option value="NanumSquareExtraBold">나눔스퀘어 아주 굵은</option>
                  <option value="NanumSquareAcb">나눔스퀘어 acB</option>
                  <option value="NanumSquareAceb">나눔스퀘어 acEB</option>
                  <option value="NanumSquareAcl">나눔스퀘어 acL</option>
                  <option value="NanumSquareAcr">나눔스퀘어 acR</option>
                  <option value="NanumSquareNeoLight">나눔스퀘어 네오 가는</option>
                  <option value="NanumSquareNeo">나눔스퀘어 네오</option>
                  <option value="NanumSquareNeoBold">나눔스퀘어 네오 굵은</option>
                  <option value="NanumSquareNeoExtraBold">나눔스퀘어 네오 아주 굵은</option>
                  <option value="NanumSquareNeoHeavy">나눔스퀘어 네오 무거운</option>
                  <option value="NanumSquareRoundLight">나눔스퀘어라운드 가는</option>
                  <option value="NanumSquareRound">나눔스퀘어라운드</option>
                  <option value="NanumSquareRoundBold">나눔스퀘어라운드 굵은</option>
                  <option value="NanumSquareRoundExtraBold">나눔스퀘어라운드 아주 굵은</option>
                  <option value="NanumHumanheavy">나눔휴먼 무거운</option>
                  <option value="NanumHumanEB">나눔휴먼 아주 굵은</option>
                  <option value="NanumHumanbold">나눔휴먼 굵은</option>
                  <option value="NanumHuman">나눔휴먼 중간</option>
                  <option value="NanumHumanlight">나눔휴먼 가는</option>
                  <option value="NanumHumanEL">나눔휴먼 아주 가는</option>
                </select>
                <p id="fontSample" class="mb-2" style="font-family: 'inherit'; text-align: center;">안녕하세요 | Hello | 你好 | こんにちは</p>
                <label for="borderSelect" class="form-label mt-3"><i class="fa-regular fa-square"></i>&nbsp;&nbsp;테두리</label>
                <select id="borderSelect" class="form-select form-select-sm mb-2">
                  <option value="none">테두리 없음</option>
                  <option value="border-primary">Primary</option>
                  <option value="border-secondary">Secondary</option>
                  <option value="border-success">Success</option>
                  <option value="border-danger">Danger</option>
                  <option value="border-warning">Warning</option>
                  <option value="border-info">Info</option>
                  <option value="border-light">Light</option>
                  <option value="border-dark">Dark</option>
                </select> 
                <label for="themeSelect" class="form-label mt-3"><i class="fa-solid fa-brush"></i>&nbsp;&nbsp;테마</label>
                <select id="themeSelect" class="form-select form-select-sm">
                  <option value="bg-warning text-dark bg-opacity-25">햇살 노랑</option>
                  <option value="bg-light text-dark bg-opacity-50">구름 흰색</option>
                  <option value="bg-primary text-dark bg-opacity-10">하늘 파랑</option>
                  <option value="bg-3030 text-light bg-opacity-75">차콜 블랙</option>
                  <option value="bg-secondary text-dark bg-opacity-50">스틸 그레이</option>
                  <option value="bg-black text-white bg-opacity-25">은은한 어둠</option>
                  <option value="bg-success text-dark bg-opacity-25">싱그러운 초록</option>
                  <option value="bg-danger text-dark bg-opacity-10">따뜻한 레드</option>
                  <option value="bg-info text-dark bg-opacity-50">맑은 물빛</option>
                  <option value="bg-success text-dark bg-opacity-10">맑은 아침</option>
                </select>
                <label for="bg-colorSelect" class="form-label mt-3"><i class="fa-solid fa-fill"></i>&nbsp;&nbsp;배경색</label>
                <select id="bg-colorSelect" class="form-select form-select-sm">
                  <option value="#ffcdd2">연한 붉은색</option>
                  <option value="#dcedc8">연한 올리브 그린</option>
                  <option value="#c8e6c9">연한 녹색</option>
                  <option value="#d1c4e9">연한 보라색</option>
                  <option value="#fce4ec">연한 분홍색</option>
                  <option value="#e3f2fd">하늘색</option>
                  <option value="#f8f9fa">밝은 회색</option>
                  <option value="#ffffff">흰색</option>
                  <option value="#212121">검정</option>
                  <option value="#ffeb3b">밝은 노란색</option>
                  <option value="#90a4ae">어두운 회색</option>
                  <option value="#e9ecef">차분한 회색</option>
                </select>
                <label for="toc-styleSelect" class="form-label mt-3"><i class="fa-solid fa-list"></i>&nbsp;&nbsp;대화목록 스타일</label>
                <select id="toc-styleSelect" class="form-select form-select-sm">
                  <option value="list-group-item-primary">Primary</option>
                  <option value="list-group-item-secondary">Secondary</option>
                  <option value="list-group-item-success">Success</option>
                  <option value="list-group-item-danger">Danger</option>
                  <option value="list-group-item-warning">Warning</option>
                  <option value="list-group-item-info">Info</option>
                  <option value="list-group-item-light">Light</option>
                  <option value="list-group-item-dark">Dark</option>
                </select>
                <label for="widthRange" class="form-label mt-3"><i class="fa-solid fa-text-width"></i>&nbsp;&nbsp;GPT 답변창의 너비(6~12)</label>
                <input type="range" class="form-range" min="6" max="12" step="1" id="widthRange" value="9">
              </form>
            </div>
            <div class="modal-footer">
              <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">닫기</button>
              <button type="submit" class="btn btn-primary" form="paletteForm">정하기</button>
            </div>
          </div>
        </div>
      </div>
      <div class="input-area">
        <form id="messageForm" style="border: 1px solid black; border-radius: 4px 4px 4px 4px; background-color: #f8f9fa;;">
          <div id="thumbnails">
            <div id="imgSpinner" class="spinner-border" role="status" style="display:none;">
              <span class="visually-hidden">Loading...</span>
            </div>
          </div>
          <div class="input-group" style="border: none; outline: none;">
            <label id="img-label" for="img"><i class="fa-solid fa-paperclip attach-icon"></i></label>
            <input id="img" type="file" accept="image/*" style="display:none" multiple>
            <textarea required minlength="3" maxlength="5000" id="myInput" name="message" class="form-control" placeholder="프롬프트를 입력해 주세요" aria-label="Message" aria-describedby="send-button" autocomplete="off" rows="1" style="resize: none; overflow-y: auto;"></textarea> 
            <button id="myBtn" class="btn btn-primary" type="submit" id="send-button"><i class="fa-solid fa-circle-arrow-up"></i></button>
          </div>          
        </form>
      </div>  
    </div>
  </div>
</div>
{% endblock %}
{% block script %}
<script type="module">
  const MODELS = {
    'model1': 'gpt-5',
    'model2': 'gpt-5-mini',
    'model3': 'gpt-5-nano',
  }

  const IMAGE_MODELS = {
    'model1': 'dall-e-2',
    'model2': 'dall-e-3',
  }

  const special_characters = {
    'image_generation': '!!',
    'web_search': '??',
    'file_input': '>>',
  }

  const defaultModel = MODELS['model1'];
  document.querySelector('body').classList.replace('mt-4', 'mt-2');
  import { createStore } from 'https://cdnjs.cloudflare.com/ajax/libs/redux/5.0.1/redux.legacy-esm.js';
  
  let fontSize = 16; // 기본 크기 (px)
  const articles = document.getElementById("article");

  document.getElementById('fontSelect').addEventListener('change', function () {
    const selectedFont = this.value;
    const fontSample = document.getElementById('fontSample');
    fontSample.style.fontFamily = selectedFont || 'inherit';
  });

  const updateFontSize = () => {
    const textElements = articles.querySelectorAll("*");
    textElements.forEach(el => {
      el.style.fontSize = fontSize + "px";
    });
  };

  function Initialize_textareaTag(sizeDefault = 16){
    const $thumbnails = document.getElementById('thumbnails');
    const children = $thumbnails.children;
    while (children.length > 1) {
      $thumbnails.removeChild(children[0]);
    }
    const $imgInput = document.getElementById('img');
    $imgInput.value = '';

    const $myInput = document.getElementById('myInput')
    $myInput.value = '';
    // $myInput.focus();
    if (sizeDefault != null) {
      fontSize = sizeDefault;
      updateFontSize();
    } 
  }

  function TOC(){
    const state = store.getState();
    const itemStyle = localStorage.getItem('toc-style') || 'list-group-item-secondary';
    let liTags = state.list_items.map(({ id, title }) => `
      <div class="position-relative"><a href='#' data-id=${id} class="subjectItem list-group-item list-group-item-action ${itemStyle} ${state.subject === title ? 'active' : ''}">${title}</a></div>
    `).join('');
    // liTags = '<div class="sideBanner"><button class="btn btn-light chatBtn" style="padding: 0.5rem; margin-top: 0.8rem;"><i class="fa-regular fa-pen-to-square"></i></button></div>' + '<div class="sideItem">' + liTags + '</div>';
    liTags = '<div class="sideItem">' + liTags + '</div>';     
    document.querySelectorAll('.toc').forEach(el => { el.innerHTML = `${liTags}`; });
    // chatBtn 클릭 시 state의 subject를 null로, content를 빈 배열로, list_items는 그대로 두는 dispatch 요청이 들어가야 할 것. 그리고 자동으로 메시지 입력창이 활성화되면서 사용자 입력을 기다리게 할 것.
    document.querySelectorAll('.chatBtn').forEach(el => {
      el.addEventListener('click', () => {
        store.dispatch({ type: 'UPDATE', content: 'newChat' });
        Initialize_textareaTag(); 
      });
    });
    // 이벤트 위임을 위한 단일 이벤트 리스너 등록 (리스너 중복 등록 방지)
    document.querySelectorAll('ul.toc').forEach(toc => {
      if (!toc.dataset.listenerAdded) {
        toc.addEventListener('click', async function(e) {
          const subjectItem = e.target.closest('.subjectItem');
          if (!subjectItem) {
            return;
          }
          e.preventDefault();
          const itemId = subjectItem.getAttribute('data-id');
          // data-id가 null이 아닐 경우, 즉 해당 목록이 이미 서버측 데이터베이스에 반영돼 있는 항목이라면 fetch 요청 시 id값을 인자로 전달해 대화 내용을 받아와 dispatch 요청
          // id, subject_id, create_date, role, content
          try {
            const response = await fetch(_URL + `/textgpt/content/${itemId}`);
            if (!response.ok) {
              throw new Error(response.status);
            }

            let answer = null;
            try {
              answer = await response.json(); // JSON 파싱 오류를 무시
            } catch (jsonError) {
              console.warn('JSON parsing error, continuing:', jsonError);
            }
            // const answer = await response.json();
            // console.log(answer.data);
            store.dispatch({ 
              type: 'UPDATE', 
              content: 'chat', 
              subject: subjectItem.textContent, 
              items: answer ? answer.data : [] // 유효한 데이터가 없으면 빈 배열 전달
            });

            // store.dispatch({ type: 'UPDATE', content: 'chat', subject: subjectItem.textContent, items: answer.data });
            Initialize_textareaTag();
          } catch (error) {
            console.error('Error:', error);
          }
        }); 
      }
      toc.dataset.listenerAdded = 'true';
    }); 
  }

  // marked 기본 설정
  marked.setOptions({
    gfm: true,
    breaks: true,
    headerIds: false,
    mangle: false,
    highlight: function(code, lang) {
      if (lang && hljs.getLanguage(lang)) {
        return hljs.highlight(code, { language: lang }).value;
      }
      return hljs.highlightAuto(code).value;
    }
  });

  // del(<del>) 무력화
  marked.use({
    renderer: {
      del(text) {
        return text; // <del> 태그로 변환하지 않고 그냥 텍스트만 반환
      }
    },
    tokenizer: {
      del(src) {
        return; // 아예 토큰을 만들지 않음
      }
    }
  });

  async function article(){
    const state = store.getState();
    async function fetchThumbnail(url) {
      try {
        const response = await fetch(url.replace('_image', '_thumbnail'));
        if (!response.ok) {
          throw new Error('Network response was not ok.');
        }
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      } catch (error) {
        console.error(error);
        return null;  
      }
    }

    async function fetchOriginalImage(url) {
      try {
        const response = await fetch(url);
        if (!response.ok) {
          throw new Error('Network response was not ok.');
        }
        const blob = await response.blob();
        return URL.createObjectURL(blob);
      } catch (error) {
        console.error(error);
        return null;
      }
    }

    const border = localStorage.getItem('border');
    const theme = localStorage.getItem('theme');
    const width = localStorage.getItem('width') || 9;
    const content = state.contents.map(el => {
      // Markdown 파싱
      let renderedDesc = marked.parse(el.desc);

      return `
        <div class="row mb-3 ${el.author === 'user' ? 'justify-content-end' : 'justify-content-start'}">
          <div class="col-md-${el.author === 'user' ? 6 : width} col-11">
            <div class="card ${border == 'none' ? '' : border} mb-2">
              <div class="card-body ${theme == '' ? 'bg-light text-dark bg-opacity-50' : theme}">
                <div class="thumbnails" data-url="${el.imgUrl}"></div>
                ${el.imgUrl.length > 0 && el.author === 'assistant'
                  ? `<span style="position: absolute; top: 1.2rem; left: 1.3rem;">
                      <input class="imgCheckBoxes form-check-input" type="checkbox" aria-label="...">
                    </span>`
                  : ''
                }
                <div data-id="${el.id}" class="markDown card-text text-start fs-6 lh-base" style="margin:0;">
                  ${renderedDesc}
                </div>
                <button type="button" class="btn-close delete_message" aria-label="Close"></button>
              </div>
            </div>
          </div>
        </div>
      `;
    }).join('');

    document.getElementById('article').innerHTML = content;

    // MathJax 처리
    if (window.MathJax) {
      MathJax.typesetPromise();
    }

    // highlight.js 실행 + 줄 번호 적용
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightElement(block);
    });
    hljs.initLineNumbersOnLoad();

    updateFontSize();
    const $currentModel = document.getElementById('currentModel');
    const $dalleSettingBtn = document.getElementById('dalleSettingBtn');
    
    if ($dalleSettingBtn.classList.contains('modeChange')) {
      const model_name = state.model.replace('gpt', 'GPT');
      $currentModel.textContent = model_name;
    } else {
      $currentModel.textContent = state.dalle_model.toUpperCase();
    }
  
    const thumbnailPromises = state.contents.map(async (el) => {
      const $target = document.querySelector(`div.thumbnails[data-url="${el.imgUrl}"]`);
      if (!($target && Array.isArray(el.imgUrl) && el.imgUrl.length > 0)) {
        return null;
      }
      for (let url of el.imgUrl) {
        // '/' 문자열이 포함돼 있지 않다면 _URL을 추가할 것
        if (!(url.includes('/'))) {
          url = _URL + '/textgpt/get_thumbnail/' + url;
        }
        const imgSrc = await fetchThumbnail(url);
        if (imgSrc) {
          const $container = document.createElement('div');
          $container.style.position = 'relative';
          $container.style.display = 'inline-block';
          $container.className = 'imgCard';
          $container.setAttribute('data-id', el.id);

          const $imgElement = document.createElement('img');
          $imgElement.src = imgSrc;
          $imgElement.style.width = '100%;'
          $imgElement.style.paddingBottom = '0.8rem';
          $container.appendChild($imgElement);

          $container.addEventListener('click', async function() {
            url = url.replace("/get_thumbnail/", "/get_image/");
            const originalImageUrl = await fetchOriginalImage(url);
            const img = new Image();
            img.onload = function() {
              const width = this.naturalWidth;
              const height = this.naturalHeight;

              // Open a new window with the size of the original image
              const newWindow = window.open('', '_blank', `width=${width}, height=${height}`);
              newWindow.document.write(`<title>Original Image</title><img src="${originalImageUrl}" style="width:100%;height:100%;object-fit:contain;">`);
              newWindow.document.close();
            };
            img.src = originalImageUrl;
          });

          $target.appendChild($container);
        } 
      }
    });
    await Promise.all(thumbnailPromises);
    // updateFontSize();
    const chatWindow = document.getElementById('article');
    if (chatWindow.lastElementChild) {
      chatWindow.lastElementChild.scrollIntoView({ behavior : 'smooth' });
    }
  
    const badgeHTML = `${state.subject}<span class="position-absolute top-0 end-0 badge rounded-pill border border-light"> ${state.contents.length / 2}</span>`; 
    const $target = document.querySelectorAll('ul.toc a.active')?.[1] || undefined;
    if ($target) {
      $target.innerHTML = badgeHTML;
      $target.scrollIntoView({ behavior : 'instant' });
    }
  }
    
  function button(){
    const state = store.getState();
    const btnState = state.disabled;
    const $myInput = document.getElementById('myInput');
    const $mySpinner = document.getElementById('mySpinner');
    document.getElementById('myBtn').disabled = btnState;
    if(btnState){
      $myInput.value = '';
      $myInput.style.height = 'auto';
      $myInput.style.height = ($myInput.scrollHeight) + 'px';
      $mySpinner.style.display = 'block';
      $mySpinner.scrollIntoView({ behavior : 'smooth' });
    } else {
      $mySpinner.style.display = 'none';
    }
  }
  
  function modelReset() {
    const $settingBtn = document.getElementById('settingBtn');
    const $dalleSettingBtn = document.getElementById('dalleSettingBtn');
    if ($settingBtn.classList.contains('modeChange')) {
      $settingBtn.classList.toggle('modeChange');
      $dalleSettingBtn.classList.toggle('modeChange');
    }
  }

  function reducer(state, action){
    if(state === undefined){
      return {
        disabled: false,
        list_items:[],
        subject: null,
        system: '',
        model: defaultModel,
        range: 1,
        contents:[],
        images:[],
        resolution: 512,
        dalle_model: 'dall-e-3',
        number_of_images: 1,
        quality_of_image: 'standard',
        size_of_image: '1024x1024',
        style_of_image: 'vivid',
      }
    }
    let newState;
    if(action.type === 'CREATE'){
      // 사용자 질문 또는 ChatGPT 응답으로 인한 CREATE 발생 시 contents에 내용을 추가하여 렌더링함
      const newContents = [...state.contents];
      const latestImages = [...state.images]; // images 상태를 클로저로 캡처
      if(action.author.startsWith('user')){
        // 사용자가 메시지를 생성하고 CREATE type 발생 시 ChatGPT에 응답 요청을 보내고, 그 응답을 받아 연쇄적으로 dispatch 호출
        newContents.push({author:'user', desc:action.desc, imgUrl:state.images});
        (async () => {
          try {
            const question = {
              'model': state.model,
              'system': state.system,
              'content': action.desc,
              'range': state.range,
              'images': latestImages, // 캡처된 images 배열을 사용
              'subject_id': $('.toc a.active')[0]?.getAttribute('data-id') || '',
            };
            const options = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(question),
            };
            
            let url_for_request = null;
            switch(action.author) {
              case 'user':
                url_for_request = _URL + '/textgpt/question/';
                break;
              case 'user2':
                url_for_request = _URL + '/textgpt/pdf_file_input/';
                break;
              case 'user3':
                url_for_request = _URL + '/textgpt/web_search/';
                break;
              default:
                url_for_request = _URL + '/textgpt/question/';
            }

            // console.log(action.desc);
            // return
            const response = await fetch(url_for_request, options);
            if(!response.ok){
              throw new Error(response.status);
            }
            const answer = await response.json();
            store.dispatch({type:'CREATE', author:'assistant', desc:answer.response});
          } catch(error) {
            console.error('Error: ', error);
          }
        })();
        const btnFlag = action.author.startsWith('user') ? true : false;
        newState = Object.assign({}, state, {
          contents: newContents,
          disabled: btnFlag, 
        });
      } else if(action.author === 'assistant'){
        newContents.push({author:action.author, desc:action.desc, imgUrl:[]});
        // 가장 최근의 질문과 응답을 데이터베이스에 저장하기 위하여 서버측에 fetch 호출
        // 전달되는 인자로는 state에 설정된 주제 및 최신의 질문과 응답
        (async () => {
          try {
            const latestContents = newContents.slice(-2);
            const _body = {
              "subject": state.subject, // 여기서는 문자열을 기대하고 있음.
              "model": state.model,
              "range": state.range, 
              "system": state.system,
              "images": latestImages, 
              "content": latestContents,
            };
            const options = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(_body),
            };
            const response = await fetch(_URL + '/textgpt/upload/', options);
            if(!response.ok){
              throw new Error(response.status);
            }
            const res = await response.json();
            // console.log(res.msgIds);
            // console.log(res.subjectId);
            store.dispatch({type:'CREATE', author:'initializer', msgIds: res.msgIds, subjectId: res.subjectId});
          } catch(error) {
            console.error('Error: ', error);
          }
        })();
        newState = Object.assign({}, state, {
          contents: newContents,
          images: [],
        });
      } else if (action.author === 'initializer'){
        const _contents = [...state.contents];
        _contents.slice(-2).forEach((obj, index) => {
          obj.id = action.msgIds[index];
        });
        const activeSubjectId = $('.toc a.active')[0]?.getAttribute('data-id');
        if (activeSubjectId == 'null') {
          const newListItems = [...state.list_items];
          newListItems[0].id = action.subjectId;

          // $('.toc a.active').each(function () {
          //   $(this).attr('data-id', action.subjectId);
          // });

          const activeElements = document.querySelectorAll('.toc a.active');
          activeElements.forEach((element) => {
            element.setAttribute('data-id', action.subjectId);
          });

          newState = Object.assign({}, state, {
            contents: _contents,
            list_items: newListItems,
            disabled: false, 
          });
        } else {
          newState = Object.assign({}, state, {
            contents: _contents,
            disabled: false, 
          });
        }
      }
    } else if (action.type === 'IMG_CREATE') {
      // 사용자 질문 또는 ChatGPT 응답으로 인한 CREATE 발생 시 contents에 내용을 추가하여 렌더링함
      const newContents = [...state.contents];
      const latestImages = [...state.images]; // images 상태를 클로저로 캡처
      if(action.author === 'user'){
        // 사용자가 메시지를 생성하고 CREATE type 발생 시 ChatGPT에 응답 요청을 보내고, 그 응답을 받아 연쇄적으로 dispatch 호출
        newContents.push({author:action.author, desc:action.desc, imgUrl:state.images});
        (async () => {
          try {
            const question = {
              'prompt': action.desc,
              'images': latestImages, // 캡처된 images 배열을 사용
              'subject_id': $('.toc a.active')[0]?.getAttribute('data-id') || '',
            };
            const options = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(question),
            };

            // console.log(action.desc);
            const response = await fetch(_URL + '/textgpt/generate_image/', options);
            if(!response.ok){
              throw new Error(response.status);
            }
            const answer = await response.json();
            const imgUrlArray = [];
            for (const msgId of answer.msgIds) {
              imgUrlArray.push(_URL + `/textgpt/get_image/${msgId}`);
            }
            // console.log(imgUrlArray);
            store.dispatch({type:'IMG_CREATE', author:'assistant', desc:answer.revised_prompt || '', images: imgUrlArray});
          } catch(error) {
            console.error('Error: ', error);
          }
        })();
        const btnFlag = action.author === 'user' ? true : false;
        newState = Object.assign({}, state, {
          contents: newContents,
          disabled: btnFlag, 
        });
      } else if (action.author === 'user2') {
        // 사용자가 메시지를 생성하고 CREATE type 발생 시 ChatGPT에 응답 요청을 보내고, 그 응답을 받아 연쇄적으로 dispatch 호출
        newContents.push({author:'user', desc:action.desc, imgUrl:state.images});
        (async () => {
          try {
            const messageIds = $(".imgCheckBoxes:checked").parent().next().map(function() {
              return $(this).attr("data-id");
            }).get();
            
            const question = {
              'model': state.model,
              'images': latestImages, // 캡처된 images 배열을 사용
              'prompt': action.desc.slice(2).trim(),
              'msgIds': messageIds,
            };
            
            const options = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(question),
            };

            const response = await fetch(_URL + '/textgpt/generate_image_by_imageAPI/', options);
            if(!response.ok){
              throw new Error(response.status);
            }

            const answer = await response.json();
            const imgUrlArray = [];
            for (const msgId of answer.msgIds) {
              imgUrlArray.push(_URL + `/textgpt/get_image/${msgId}`);
            }
            // console.log(imgUrlArray);
            store.dispatch({type:'IMG_CREATE', author:'assistant', desc:answer.revised_prompt || '', images: imgUrlArray});
          } catch(error) {
            console.error('Error: ', error);
          }
        })();
        const btnFlag = action.author === 'user2' ? true : false;
        newState = Object.assign({}, state, {
          contents: newContents,
          disabled: btnFlag, 
        });
      } else if(action.author === 'assistant'){
        newContents.push({author:action.author, desc:action.desc, imgUrl:action.images});
        // 가장 최근의 질문과 응답을 데이터베이스에 저장하기 위하여 서버측에 fetch 호출
        // 전달되는 인자로는 state에 설정된 주제 및 최신의 질문과 응답
        (async () => {
          try {
            const latestContents = newContents.slice(-2);
            const _body = {
              "subject": state.subject, // 여기서는 문자열을 기대하고 있음.
              "images": action.images, 
              "source_images": latestImages,
              "content": latestContents,
            };
            const options = {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify(_body),
            };
            const response = await fetch(_URL + '/textgpt/upload_generated_image/', options);
            if(!response.ok){
              throw new Error(response.status);
            }
            const res = await response.json();
            // console.log(res.msgIds);
            // console.log(res.subjectId);
            store.dispatch({type:'CREATE', author:'initializer', msgIds: res.msgIds, subjectId: res.subjectId});
          } catch(error) {
            console.error('Error: ', error);
          }
        })();
        newState = Object.assign({}, state, {
          contents: newContents,
          images: [],
        });
      } else if (action.author === 'initializer'){
        const _contents = [...state.contents];
        _contents.slice(-2).forEach((obj, index) => {
          obj.id = action.msgIds[index];
        });
        const activeSubjectId = $('.toc a.active')[0]?.getAttribute('data-id');
        if (activeSubjectId == 'null') {
          const newListItems = [...state.list_items];
          newListItems[0].id = action.subjectId;

          // $('.toc a.active').each(function () {
          //   $(this).attr('data-id', action.subjectId);
          // });

          const activeElements = document.querySelectorAll('.toc a.active');
          activeElements.forEach((element) => {
            element.setAttribute('data-id', action.subjectId);
          });

          newState = Object.assign({}, state, {
            contents: _contents,
            list_items: newListItems,
            disabled: false, 
          });
        } else {
          newState = Object.assign({}, state, {
            contents: _contents,
            disabled: false, 
          });
        }
      }
    } else if(action.type === 'SUBJECT'){
      if (action.target === 'subject') {
        // 모달창에 주제를 입력하고 정하기를 클릭하면 SUBJECT 발생. 데이터베이스 반영 전이므로 id는 없음(null)으로 설정.   
        const newListItems = state.list_items.slice();
        newListItems.unshift({
          'id': null,
          'title': action.subject,
        });
        newState = Object.assign({}, state, {
          list_items: newListItems,
          subject: action.subject,
          disabled: false,
        });
      } else if (action.target === 'system') {
        // system 모달창에 주제에 관한 gpt 역할을 입력하면 정하기를 클릭 시
        getChatList();
        newState = Object.assign({}, state, {
          system: action.content,
          model: action.model,
          range: action.range,
          resolution: action.resolution,
          subject: action.title,
        });
      } else if (action.target === 'dalle_system') {
        getChatList();
        newState = Object.assign({}, state, {
          dalle_model: action.model,
          number_of_images: action.number,
          quality_of_image: action.quality,
          size_of_image: action.size,
          style_of_image: action.style,
        });
      }
    } else if(action.type === 'UPDATE'){
      // 전달받은 주제 항목에서 subject.id와 subject.title만으로 구성된 객체 배열을 생성해 list_items에 전달하여 화면 갱신 
      if (action.content === 'list') {
        const _items = action.items.map(el => ({ 
          'id': el.id, 
          'title': el.title,
          'system': el.system,
          'model': el.model,
          'range': el.range,
          'resolution': el.resolution,
          'dalle_model': el.dalle_model,
          'number_of_images': el.number_of_images,
          'quality_of_image': el.quality_of_image,
          'size_of_image': el.size_of_image,
          'style_of_image': el.style_of_image, 
        }));
        // console.log(_items);
        newState = Object.assign({}, state, {
          list_items: _items,
        });
      } else if (action.content === 'chat') {
        modelReset();
        // 데이터베이스의 Message 모델로부터 전달받은 배열 객체에서 content와 role만을 추출해 새로운 content 생성
        const _contents = action.items.map(el => ({
          'id': el.id,
          'author': el.role,
          'desc': el.content,
          'imgUrl': el.msg_images,
        }));
        // subject에는 id가 아닌 문자열이 들어가야 함. 목록을 클릭했을 때 클릭한 목록의 문자열을 넣으면 되지 않을까? 153줄 참조
        const idx = state.list_items.findIndex(item => item.title === action.subject);
        newState = Object.assign({}, state, {
          subject: action.subject,
          system: state.list_items[idx].system,
          model: state.list_items[idx].model,
          range: state.list_items[idx].range,
          resolution: state.list_items[idx].resolution, 
          images: [],
          contents: _contents,
          dalle_model: state.list_items[idx].dalle_model || 'dall-e-3',
          number_of_images: state.list_items[idx].number_of_images || 1,
          quality_of_image: state.list_items[idx].quality_of_image || 'standard',
          size_of_image: state.list_items[idx].size_of_image || '1024x1024',
          style_of_image: state.list_items[idx].style_of_image || 'vivid',
          });
      } else if (action.content === 'newChat') {
        modelReset();
        // state의 subject를 null로, contents를 빈 배열로, list_items는 그대로
        newState = Object.assign({}, state, {
          subject: null,
          system: '',
          model: defaultModel,
          range: 1,
          contents: [],
          images: [],
          resolution: 512,
          dalle_model: 'dall-e-3',
          number_of_images: 1,
          quality_of_image: 'standard',
          size_of_image: '1024x1024',
          style_of_image: 'vivid',
        });
      } else if (action.content === 'reset') {
        modelReset();
        const newList_items = [...state.list_items.slice(0, action.idx), ...state.list_items.slice(action.idx+1)];
        newState = Object.assign({}, state, {
          subject: null,
          list_items: newList_items,
          system: '',
          model: defaultModel,
          range: 1,
          contents: [],
          images: [],
          resolution: 512,
          dalle_model: 'dall-e-3',
          number_of_images: 1,
          quality_of_image: 'standard',
          size_of_image: '1024x1024',
          style_of_image: 'vivid',
        });
      } else if (action.content === 'add_images') {
        newState = Object.assign({}, state, {
          images: [...state.images, ...action.images],
        });
      } else if (action.content === 'delete_image') {
        const _idx = state.images.findIndex(item => item === action.imageStr);
        if (_idx != -1) {
          newState = Object.assign({}, state, {
            images: [...state.images.slice(0, _idx), ...state.images.slice(_idx + 1)],
          });
        } 
      } else if (action.content === 'delete_messages') {
        const targetIdsSet = new Set(action.targetIds); // Set으로 변환해 빠른 조회 가능
        newState = {
          ...state,
          contents: state.contents.filter(item => !targetIdsSet.has(item.id)), // 삭제 대상 필터링
        };
        // console.log('SET!');
      }
    }
    return newState;
  }
  // 서버로부터 로그인한 사용자가 작성한 주제 항목들을 가나다 순으로 받아오고 dispatch 호출 시 이를 인자로 전달함. 
  // id, user_id, title, system, create_date 등
  const getChatList = async () => {
    let response;
    try {
      const searchWord = localStorage.getItem('kw') || '';
      if (searchWord) {
        response = await fetch(_URL + `/textgpt/chatlist/${encodeURIComponent(searchWord)}`, {
          method: 'GET',
        });
      } else {
        response = await fetch(_URL + '/textgpt/chatlist/');
      }
      if(!response.ok){
        throw new Error(response.status);
      } else if(response.status === 204){
        console.log('No Content');
        return
      }
      const answer = await response.json();
      store.dispatch({type:'UPDATE', content:'list', items:answer.data});
      document.getElementById('searchInput').placeholder = searchWord;
      document.getElementById('searchInput2').placeholder = searchWord;
    } catch(error) {
      console.error('Error: ', error);
    }
  }
  
  const productionURL = 'http://121.189.157.152:8080';
  const testURL = 'http://127.0.0.1:8080';
  const localURL = 'http://172.30.1.25:8080';
  let _URL = null;
  if (window.location.href.split('/')[2] === '127.0.0.1:8080'){
    _URL = testURL;
  } else if (window.location.href.split('/')[2] === '172.30.1.25:8080'){
    _URL = localURL;
  } else {
    _URL = productionURL;
  }

  const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
  window.store = store;
  store.subscribe(TOC);
  store.subscribe(article);
  store.subscribe(button);
  getChatList(); 

  // 주제에 문자열에 추가할 사용자 지정 시간 포맷을 정의
  Date.prototype.customFormat = function() {
    const yyyy = this.getFullYear();
    const MM = this.getMonth() < 9 ? `0${this.getMonth() + 1}` : this.getMonth() + 1;
    const dd = this.getDate() < 10 ? `0${this.getDate()}` : this.getDate();
    const HH = this.getHours() < 10 ? `0${this.getHours()}` : this.getHours();
    const mm = this.getMinutes() < 10 ? `0${this.getMinutes()}` : this.getMinutes();
    const ss = this.getSeconds() < 10 ? `0${this.getSeconds()}` : this.getSeconds(); 
    return `${yyyy}${MM}${dd}_${HH}:${mm}:${ss}`;
  }

  window.onload = function(){
    const $modelsDiv = document.getElementById('models');
    const modelHTML = Object.entries(MODELS).map(item => {
      return `
        <input type="radio" class="btn-check" name="models" id="${item[0]}" autocomplete="off">
        <label class="btn" for="${item[0]}">${item[1]}</label>
      `
    }).join('');
    $modelsDiv.innerHTML = modelHTML;

    const imageModelHTML = Object.entries(IMAGE_MODELS).map(item => {
      return `
        <input type="radio" class="btn-check" name="dallemodels" id="${item[1]}" autocomplete="off">
        <label class="btn" for="${item[1].toLowerCase()}">${item[1]}</label>
      `
    }).join('');
    $("#imageModelSelection").html(imageModelHTML);

    const $myInput = document.getElementById('myInput');
    // 메시지 입력창에서 줄바꿈이 일어났을 때 스크롤 내 높이를 조정해 사용자가 입력하는 내용을 볼 수 있도록 함.
    $myInput.addEventListener('input', () => {
      $myInput.style.height = 'auto';
      $myInput.style.height = ($myInput.scrollHeight) + 'px';
    });

    document.getElementById('article').style.fontFamily = localStorage.getItem('font') || 'inherit';
    const listElems = document.querySelectorAll('.toc');
    listElems.forEach((toc) => {
      toc.style.fontFamily = localStorage.getItem('font') || 'inherit';
    });
    document.getElementById('sidebar').style.backgroundColor = localStorage.getItem('bg-color') || '#e9ecef';
    document.getElementById('chatWindow').style.backgroundColor = localStorage.getItem('bg-color') || '#e9ecef';
    const selectedBgColor = localStorage.getItem('bg-color');
    const $buttons = document.querySelectorAll('.btn-transparent');
    const $model = document.getElementById('currentModel');
    
    if (selectedBgColor === '#212121') {
      $buttons.forEach(button => {
        const icon = button.querySelector('i');
        if (icon) {
          icon.style.color = 'white';
        }
      });
      $model.style.color = 'white';
      document.getElementById('mySpinner').classList.remove('text-dark');
      document.getElementById('mySpinner').classList.add('text-light');
    } else {
      $buttons.forEach(button => {
        const icon = button.querySelector('i');
        if (icon) {
          icon.style.color = 'black';
        }
      });
      $model.style.color = 'black';
      document.getElementById('mySpinner').classList.remove('text-light');
      document.getElementById('mySpinner').classList.add('text-dark');
    }
    // '전송' 클릭 시 발생하는 이벤트 내용을 정의 state의 subject가 null로 비어있을 경우에는 메시지 전송이 아닌 모달창이 띄워지며, 이미 subject가 있을 시에는 입력창의 메시지를 chatGPT에 질의함.
    document.getElementById('messageForm').addEventListener('submit', function(event){
      event.preventDefault();
      if (!!store.getState().subject) {
        const _author = 'user';
        const _desc = event.target.message.value.trim();
        
        const currentModel = document.getElementById('currentModel').textContent.toLowerCase().trim();
        const imageModelFlag = Object.values(IMAGE_MODELS).includes(currentModel);
        const addtionalFeaturesFlag = Object.values(special_characters).some(el => _desc.startsWith(el));
        
        if (imageModelFlag) {
          store.dispatch({type:'IMG_CREATE', author:_author, desc: _desc});
        } else if (addtionalFeaturesFlag) {
          const featureKey = Object.keys(special_characters).find(key => _desc.startsWith(special_characters[key]));
          switch (featureKey) {
            case 'image_generation':
              console.log('이미지 생성 기능 실행');
              store.dispatch({type:'IMG_CREATE', author:'user2', desc: _desc});
              break;
            case 'file_input':
              console.log('파일 입력 기능 실행');
              store.dispatch({type:'CREATE', author:'user2', desc: _desc});
              break;
            case 'web_search':
              console.log('웹 검색 기능 실행');
              store.dispatch({type:'CREATE', author:'user3', desc: _desc});
              break;
            default:
              console.log('알 수 없는 기능');
          }
        } else {
          store.dispatch({type:'CREATE', author:_author, desc: _desc});
        }
        Initialize_textareaTag(null); 
      } else {
        $('#modalBtn').click();
      }
    });

    document.getElementById('searchForm').addEventListener('submit', async function(event) {
      event.preventDefault(); // 기본 폼 제출 동작 방지
      const searchInput = event.target.searchInput.value.trim(); // 입력값 가져오기 및 공백 제거
      localStorage.setItem('kw', searchInput);
      try {
        getChatList();
      } catch (error) {
        console.error('Fetch error:', error);
      }
      // 입력 필드 초기화
      event.target.searchInput.value = '';
      event.target.searchInput.placeholder = searchInput;
    });

    document.getElementById('searchForm2').addEventListener('submit', async function(event) {
      event.preventDefault(); // 기본 폼 제출 동작 방지
      const searchInput = event.target.searchInput2.value.trim(); // 입력값 가져오기 및 공백 제거
      localStorage.setItem('kw', searchInput);
      try {
        getChatList();
      } catch (error) {
        console.error('Fetch error:', error);
      }
      // 입력 필드 초기화
      event.target.searchInput2.value = '';
      event.target.searchInput2.placeholder = searchInput;
    });

    // 모달창의 세부 항목의 내용 지정하기
    const exampleModal = document.getElementById('exampleModal')
    if (exampleModal) {
      exampleModal.addEventListener('show.bs.modal', event => {
        // Button that triggered the modal
        const button = event.relatedTarget
        // Extract info from data-bs-* attributes
        const recipient = button.getAttribute('data-bs-whatever')
        const modalTitle = exampleModal.querySelector('.modal-title')
        const modalBodyInput = exampleModal.querySelector('.modal-body input')
        modalTitle.textContent = `${recipient} 님, 채팅방의 주제를 정해주세요.`;
      })
    }
    // system 모달창의 세부 항목의 내용 지정하기
    const systemModal = document.getElementById('systemModal')
    if (systemModal) {
      systemModal.addEventListener('show.bs.modal', event => {
        // 포커스를 첫 번째 입력 요소로 이동
        systemModal.querySelector('input, textarea, button').focus();
        systemModal.setAttribute('aria-hidden', 'false');
        // Button that triggered the modal
        const button = event.relatedTarget
        // Extract info from data-bs-* attributes
        const recipient = button.getAttribute('data-bs-whatever')
        const modalTitle = systemModal.querySelector('.modal-title')
        const modalBodyInput = systemModal.querySelector('.modal-body input')
        modalTitle.textContent = 'GPT Preferences';
      });

      systemModal.addEventListener('hidden.bs.modal', function () {
        // 포커스를 모달을 연 버튼으로 복원
        document.getElementById('systemBtn').focus();
        systemModal.setAttribute('aria-hidden', 'true');
      });
    }
    // dall-e 모달창의 세부 항목의 내용 지정하기
    const dalleModal = document.getElementById('dalleModal')
    if (dalleModal) {
      dalleModal.addEventListener('show.bs.modal', event => {
        // 포커스를 첫 번째 입력 요소로 이동
        dalleModal.querySelector('input, button').focus();
        dalleModal.setAttribute('aria-hidden', 'false');
        // Button that triggered the modal
        const button = event.relatedTarget
        // Extract info from data-bs-* attributes
        const recipient = button.getAttribute('data-bs-whatever')
        const modalTitle = dalleModal.querySelector('.modal-title')
        const modalBodyInput = dalleModal.querySelector('.modal-body input')
        modalTitle.textContent = 'DALL-E Preferences';
      });

      dalleModal.addEventListener('hidden.bs.modal', function () {
        // 포커스를 모달을 연 버튼으로 복원
        document.getElementById('dalleBtn').focus();
        dalleModal.setAttribute('aria-hidden', 'true');
      });
    }
    // palette 모달창의 세부 항목의 내용 지정하기
    const paletteModal = document.getElementById('paletteModal')
    if (paletteModal) {
      paletteModal.addEventListener('show.bs.modal', event => {
        // 포커스를 첫 번째 입력 요소로 이동
        paletteModal.querySelector('input, button').focus();
        paletteModal.setAttribute('aria-hidden', 'false');
        // Button that triggered the modal
        const button = event.relatedTarget
        // Extract info from data-bs-* attributes
        const recipient = button.getAttribute('data-bs-whatever')
        const modalTitle = paletteModal.querySelector('.modal-title')
        const modalBodyInput = paletteModal.querySelector('.modal-body input')
        modalTitle.textContent = '글꼴 및 디자인 설정';
        // LocalStorage에서 값 가져오기
        const savedFont = localStorage.getItem('font');
        const savedBorder = localStorage.getItem('border');
        const savedTheme = localStorage.getItem('theme');
        const savedColor = localStorage.getItem('bg-color');
        const savedStyle = localStorage.getItem('toc-style');
        const savedWidth = localStorage.getItem('width');

        // 각 select 요소
        const fontSelect = document.getElementById('fontSelect');
        const borderSelect = document.getElementById('borderSelect');
        const themeSelect = document.getElementById('themeSelect');
        const bgcolorSelect = document.getElementById('bg-colorSelect');
        const tocstyleSelect = document.getElementById('toc-styleSelect');
        const widthSelect = document.getElementById('widthRange');

        // 기존 값이 있으면 해당 값으로 선택
        if (savedFont) {
          fontSelect.value = savedFont;
          document.getElementById('fontSample').style.fontFamily = savedFont;
        }
        if (savedBorder) {
          borderSelect.value = savedBorder;
        }
        if (savedTheme) {
          themeSelect.value = savedTheme;
        }
        if (savedColor) {
          bgcolorSelect.value = savedColor;
        }
        if (savedStyle) {
          tocstyleSelect.value = savedStyle;
        }
        if (savedWidth) {
          widthSelect.value = savedWidth;
        }
      });

      paletteModal.addEventListener('hidden.bs.modal', function () {
        // 포커스를 모달을 연 버튼으로 복원
        document.getElementById('paletteBtn').focus();
        paletteModal.setAttribute('aria-hidden', 'true');
      });
    }
    // 모달창에서 '정하기'를 클릭했을 시, 입력한 주제명에 사용자 지정 시간 포맷을 추가하고 이를 반영하기 위한 dispatch 호출. 질문 입력창에 값이 있을 시에만 '전송'을 자동으로 클릭.
    document.getElementById('modalForm').addEventListener('submit', event => {
      event.preventDefault();
      const date = new Date();
      const _subject = document.getElementById('chatTopic').value + ' ' + date.customFormat();
      store.dispatch({type:'SUBJECT', target:'subject', subject:_subject });
      $('#exampleModal').modal('hide');
      if(document.getElementById('myInput').value){
        $('#myBtn').click();
      }
    });
    // system 모달창에서 '정하기'를 클릭했을 시, 주제에 GPT 역할을 반영하기 위한 dispatch 호출.
    document.getElementById('systemForm').addEventListener('submit', event => {
      event.preventDefault();
      const selectedModelLabel = document.querySelector('input[name="models"]:checked').nextElementSibling.textContent;  // 체크된 라디오 버튼의 텍스트 값 가져오기
      const range_val = document.getElementById('memoryRange').value;
      const selectedResolutionLabel = document.querySelector('input[name="resolution"]:checked').nextElementSibling.textContent;
      const gpt_role = document.getElementById('systemInput').value;
      const topic_val = document.getElementById('topicInput').value;
      $('#systemModal').modal('hide');
      (async () => {
        const _id = $('.toc a.active')[0].getAttribute('data-id');
        try {
          const update = {
            'id': _id,
            'system': gpt_role,
            'range': range_val,
            'resolution': selectedResolutionLabel,
            'model': selectedModelLabel,
            'topic': topic_val,
          };
          const options = {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(update),
          };
          const response = await fetch(_URL + '/textgpt/update/system/', options);
          if(!response.ok){
            throw new Error(response.status);
          }
          const answer = await response.json();
          // console.log(answer);
          store.dispatch({type:'SUBJECT', target:'system', content: gpt_role, range: range_val, model: selectedModelLabel.toLowerCase(), title: topic_val, resolution: selectedResolutionLabel});
        } catch(error) {
          console.error('Error: ', error);
        }
      })();
    });
    // dalle 모달창에서 '정하기'를 클릭했을 시, 주제에 dalle 설정을 반영하기 위한 dispatch 호출.
    document.getElementById('dalleForm').addEventListener('submit', event => {
      event.preventDefault();
      const selectedModelLabel = document.querySelector('input[name="dallemodels"]:checked').nextElementSibling.textContent.toLowerCase();  // 체크된 라디오 버튼의 텍스트 값 가져오기
      const range_val = document.getElementById('numberRange').value;
      const selectedQualityInput = document.querySelector('input[name="quality"]:checked');
      const selectedQualityLabel = selectedQualityInput ? selectedQualityInput.nextElementSibling.textContent : 'standard';
      const selectedSize = document.getElementById('dalleSize').value;
      const selectedStyleInput = document.querySelector('input[name="dalleStyle"]:checked');
      const selectedStyleLabel = selectedStyleInput ? selectedStyleInput.nextElementSibling.textContent : 'vivid';
      $('#dalleModal').modal('hide');
      // console.log(`model: ${selectedModelLabel}, range_val: ${range_val}, quality: ${selectedQualityLabel}, size: ${selectedSize}, style: ${selectedStyleLabel}`);
      (async () => {
        const _id = $('.toc a.active')[0].getAttribute('data-id');
        try {
          const update = {
            'id': _id,
            'dalle_model': selectedModelLabel,
            'number_of_images': range_val,
            'quality_of_image': selectedQualityLabel,
            'size_of_image': selectedSize,
            'style_of_image': selectedStyleLabel,
          };
          const options = {
            method: 'PUT',
            headers: {
              'Content-Type': 'application/json',
            },
            body: JSON.stringify(update),
          };
          const response = await fetch(_URL + '/textgpt/update/dalle_setting/', options);
          if(!response.ok){
            throw new Error(response.status);
          }
          const answer = await response.json();
          // console.log(answer);
          store.dispatch({type:'SUBJECT', target:'dalle_system', model: selectedModelLabel, number: range_val, quality: selectedQualityLabel, size: selectedSize, style: selectedStyleLabel});
        } catch(error) {
          console.error('Error: ', error);
        }
      })();
    });
    // palette 모달창에서 '정하기'를 클릭했을 시, 글꼴과 배경디자인을 화면에 반영하기 위한 dispatch 호출
    document.getElementById('paletteForm').addEventListener('submit', event => {
      event.preventDefault();
      const selectedFont = document.getElementById('fontSelect').value;
      const selectedBorder = document.getElementById('borderSelect').value;
      const selectedTheme = document.getElementById('themeSelect').value;
      const selectedBgColor = document.getElementById('bg-colorSelect').value;
      const selectedStyle = document.getElementById('toc-styleSelect').value;
      const selectedWidth = document.getElementById('widthRange').value;
      const $sidebar = document.getElementById('sidebar');
      const $chatWindow = document.getElementById('chatWindow');
      document.getElementById('article').style.fontFamily = selectedFont;
      
      const listElems = document.querySelectorAll('.toc');
      listElems.forEach((toc) => {
        toc.style.fontFamily = selectedFont;
      });

      const subjectItems = document.querySelectorAll('.subjectItem');
      const regex = /^list-group-item-(?!a)\w*/;

      subjectItems.forEach(elem => {
        // 우선 클래스 배열을 복사하여 변경할 클래스명들을 저장하기 위함
        const classListArray = Array.from(elem.classList);
        
        classListArray.forEach(cls => {
          const flag = regex.test(cls);
          if (flag) {
            elem.classList.remove(cls); // 클래스 삭제
          }
        });
        
        // 사용자가 원하는 클래스를 추가할 수 있도록
        elem.classList.add(selectedStyle);
      });

      const $spinner = document.getElementById('mySpinner');
      const cards = document.querySelectorAll('.card');
      cards.forEach(card => {
        // 기존 'border-*' 클래스 제거
        card.classList.forEach(cls => {
          if (cls.startsWith('border-')) {
            card.classList.remove(cls);
          }
        });
        // 새로운 'border-dark' 클래스 추가
        if (selectedBorder != 'none') {
          card.classList.add(selectedBorder);
        }
      });
      const cardBody = document.querySelectorAll('.card-body');
      cardBody.forEach(card => {
        // 기존의 'bg-* text-* bg-opacity-*' 클래스 제거
        card.classList.remove(...Array.from(card.classList).filter(cls => 
          cls.startsWith('bg-') || cls.startsWith('text-') || cls.startsWith('bg-opacity-')
        ));

        // 선택된 새로운 클래스 추가
        card.classList.add(...selectedTheme.split(' '));
      });

      // 모든 'justify-content-start' 클래스를 가진 div 요소를 선택
      const startDivs = document.querySelectorAll('#article .justify-content-start');

      // 각 div의 자식 요소를 검사
      startDivs.forEach(div => {
        // col-md-로 시작하는 클래스를 가진 자식 요소를 찾음
        const colMdElement = div.querySelector('[class*="col-md-"]');

        if (colMdElement) {
          // 기존 클래스 중 'col-md-'로 시작하는 클래스를 모두 제거
          colMdElement.classList.forEach(className => {
            if (className.startsWith('col-md-')) {
              colMdElement.classList.remove(className);
            }
          });

          // 'col-md-11' 클래스 추가
          colMdElement.classList.add(`col-md-${selectedWidth}`);
        }
      });

      const $buttons = document.querySelectorAll('.btn-transparent');
      const $model = document.getElementById('currentModel');
      if (selectedBgColor === '#212121') {
        $buttons.forEach(button => {
          const icon = button.querySelector('i');
          if (icon) {
            icon.style.color = 'white';
          }
        });
        $model.style.color = 'white';
        if ($spinner.classList.contains('text-dark')) {
          document.getElementById('mySpinner').classList.remove('text-dark');
          document.getElementById('mySpinner').classList.add('text-light');
        }
      } else {
        $buttons.forEach(button => {
          const icon = button.querySelector('i');
          if (icon) {
            icon.style.color = 'black';
          }
        });
        $model.style.color = 'black';
        if ($spinner.classList.contains('text-light')) {
          document.getElementById('mySpinner').classList.remove('text-light');
          document.getElementById('mySpinner').classList.add('text-dark');
        }
      }
      
      $sidebar.style.backgroundColor = selectedBgColor;
      $chatWindow.style.backgroundColor = selectedBgColor;
      localStorage.setItem('font', selectedFont);
      localStorage.setItem('border', selectedBorder);
      localStorage.setItem('theme', selectedTheme);
      localStorage.setItem('bg-color', selectedBgColor);
      localStorage.setItem('toc-style', selectedStyle);
      localStorage.setItem('width', selectedWidth);
      $('#paletteModal').modal('hide');
    });
    // 배너에 있는 '#deleteBtn' 클릭 시, state의 subject를 인자로 전달하며 해당 주제 및 대화글의 삭제를 위한 fetch 요청을 수행함
    // 삭제 요청 전 사용자에게 선택에 대해 확인하는 절차를 거칠 것
    // fetch 요청 후 삭제 완료 메시지 표시. 이후 초기화
    document.getElementById('deleteBtn').addEventListener('click', async event => {
      const activeItems = $('.toc a.active');
      if (!activeItems.length) {
        return;
      }
      const state = store.getState();
      const itemId = activeItems[0].getAttribute('data-id');
      if(confirm(`${state.subject} 주제의 및 모든 대화 내용을 삭제하시겠습니까?`)){
        const _idx = state.list_items.findIndex(item => item.title === state.subject);
        try {
          const response = await fetch(_URL + `/textgpt/delete/${itemId}`, {
            method: 'DELETE',
            headers: {
              'Content-Type': 'application/json'
            }
          });
          if (!response.ok){
            throw new Error(`서버 오류: ${response.status}`);
          }
          const result = await response.json();
          // console.log(result);
          alert("정상적으로 삭제하였습니다.")
          // 삭제 완료 후 초기화 작업
          store.dispatch({ type: 'UPDATE', content: 'reset', idx:_idx });
        } catch (error) {
          console.error('Error: ', error);
          alert("삭제 중 오류가 발생하였습니다.");
        }
      } else {
        alert("작업을 취소하셨습니다.")
      }
    });

    document.getElementById('settingBtn').addEventListener('click', () => {
      const state = store.getState();
      const activeItems = $('.toc a.active');
      if (!activeItems.length) {
        return;
      }

      const modelStr = Object.entries(MODELS).filter(model => model[1] === state.model)[0];
      const modelTag = '#'.concat(modelStr);
      const $elem = $(modelTag);
      $elem.prop('checked', true);
      
      const resolutions = {
        '512': '#resolution1',
        '1024': '#resolution2',
        '2048': '#resolution3'
      };
      let $resElem = resolutions[state.resolution.toString()];
      if($resElem) {
        $($resElem).prop('checked', true);
      }
      
      $('#systemInput').val(state.system);
      $('#memoryRange').val(state.range);
      $('#topicInput').val(state.subject);
      $('#systemBtn').click();
    });

    document.getElementById('dalleSettingBtn').addEventListener('click', () => {
      const state = store.getState();
      const activeItems = $('.toc a.active');
      if (!activeItems.length) {
        return;
      }

      const $elem = (state.dalle_model === 'dall-e-3' ? $('#dall-e-3') : $('#dall-e-2'));
      $elem.prop('checked', true);

      const $dalleForm = document.getElementById('dalleForm');
      const $dalle3Radio = document.getElementById('dall-e-3');
      const $dalle2Radio = document.getElementById('dall-e-2');
      const $numberRange = document.getElementById('numberRange');
      const $quality1 = document.getElementById('quality1');
      const $quality2 = document.getElementById('quality2');
      const $style1 = document.getElementById('style1');
      const $style2 = document.getElementById('style2');
      const $dalleSize = document.getElementById('dalleSize');
      const $sizeOptions = $dalleSize.querySelectorAll('option');

      const handleModelChange = () => {
        if ($dalle2Radio.checked) {
          // Disable 'hd', 'style' option
          $numberRange.removeAttribute('disabled');
          $quality1.checked = false;
          $quality2.checked = false;
          $style1.checked = false;
          $style2.checked = false;
          const temp = ['256x256', '512x512'];
          $sizeOptions.forEach(option => {
            if(temp.includes(option.value)) {
              option.removeAttribute('disabled');
            }
          });
          document.querySelector('select option[value="1024x1024"]').selected = true;
          $quality1.setAttribute('disabled', true);
          $quality2.setAttribute('disabled', true);
          $style1.setAttribute('disabled', true);
          $style2.setAttribute('disabled', true);
          const targets = ['1024x1792', '1792x1024'];
          $sizeOptions.forEach(option => {
            if(targets.includes(option.value)) {
              option.setAttribute('disabled', true);
            }
          });
        } else {
          // Enable 'hd', 'style' option
          const temp = ['1024x1792', '1792x1024'];
          $sizeOptions.forEach(option => {
            if(temp.includes(option.value)) {
              option.removeAttribute('disabled');
            }
          });
          document.querySelector('select option[value="1024x1024"]').selected = true;
          $numberRange.value = '1';
          $numberRange.setAttribute('disabled', true);
          $quality1.removeAttribute('disabled');
          $quality2.removeAttribute('disabled');
          $style1.removeAttribute('disabled');
          $style2.removeAttribute('disabled');
          $quality1.checked = true;
          $style1.checked = true;
          const targets = ['256x256', '512x512'];
          $sizeOptions.forEach(option => {
            if(targets.includes(option.value)) {
              option.setAttribute('disabled', true);
            }
          });
        }
      };
      $dalle3Radio.addEventListener('change', handleModelChange);
      $dalle2Radio.addEventListener('change', handleModelChange);
      handleModelChange();

      const qualities = {
        'standard': '#quality1',
        'hd': '#quality2',
      };
      let $qualElem = qualities[state.quality_of_image];
      if($qualElem) {
        $($qualElem).prop('checked', true);
      }

      const styles = {
        'vivid': '#style1',
        'natural': '#style2',
      };
      let $styleElem = styles[state.style_of_image];
      if($styleElem) {
        $($styleElem).prop('checked', true);
      }

      $('#numberRange').val(state.number_of_images);
      $('#dalleSize').val(state.size_of_image);
      $('#dalleBtn').click();
    });

    document.getElementById('paletteBtn').addEventListener('click', () => {
      $('#designBtn').click();
    });

    document.getElementById('article').addEventListener('click', async function(e) {
      if (!e.target.classList.contains('delete_message')) return; 

      const $delete_message = e.target.previousElementSibling;
      if (!$delete_message) {
        console.log('.delete_message 버튼의 이전 요소가 존재하지 않습니다.');
      }
      e.target.setAttribute('disabled', 'true');
      
      const first_id = $delete_message.getAttribute('data-id');
      let second_id = null;
      const targetSection = $delete_message.closest('.row');

      if (!targetSection) {
        console.error('targetSection을 찾을 수 없습니다.');
        return;
      }

      if (targetSection.classList.contains('justify-content-end')) {
        second_id = targetSection.nextElementSibling.querySelector('.markDown')?.getAttribute('data-id');
        targetSection.nextElementSibling.remove();
      } else if (targetSection.classList.contains('justify-content-start')) {
        second_id = targetSection.previousElementSibling.querySelector('.markDown')?.getAttribute('data-id');
        targetSection.previousElementSibling.remove();
      }
      targetSection.remove();
      
      // console.log(first_id, second_id);

      try {
        const id_list = {
          'first_id': first_id,
          'second_id': second_id,
        };
        const options = {
          method: 'DELETE',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(id_list),
        };
        const response = await fetch(_URL + '/textgpt/delete/message/', options);
        if(!response.ok){
          throw new Error(response.status);
        }
        const answer = await response.json();
        console.log('삭제 성공: ', answer);
        store.dispatch({ type:'UPDATE', content:'delete_messages', targetIds:[parseInt(first_id), parseInt(second_id)] });
      } catch(error) {
        console.error('Error: ', error);
      }
    });

    document.getElementById('img').addEventListener('change', function(e) {
      const currentModel = document.getElementById('currentModel').textContent;
      const state = store.getState();
      const maxFiles = currentModel.startsWith('GPT') ? 3 : 2;
      const files = this.files;
      const $imgContainers = document.getElementsByClassName('.imgContainer');
      const imgUrlArray = [];

      if (files.length > maxFiles || $imgContainers.length > maxFiles) {
        alert(`최대 ${maxFiles}개의 파일만 선택할 수 있습니다.`);
        this.value = "";
      } else {
        const $imgSpinner = document.getElementById('imgSpinner');
        $imgSpinner.style.display = 'inline-block';
        const formData = new FormData();
        // console.log(this, files);

        for (const file of this.files) {
          formData.append('images[]', file);
        }
        formData.append('resolution', state.resolution);
        formData.append('currentModel', currentModel);

        fetch(_URL + '/textgpt/upload_image/', {
          method: 'POST',
          body: formData,
        })
        .then(res => {
          if (!res.ok) {
            throw new Error('Network response was not ok');
          }
          return res.json();
        })
        .then(data => {
          // console.log('Success: ', data);
          Promise.all(data.msgIds.map(msgId => {
            return fetch(_URL + `/textgpt/get_thumbnail/${msgId}`)
              .then(response => {
                if (!response.ok) {
                  throw new Error('Network response was not ok');
                }
                imgUrlArray.push(_URL + `/textgpt/get_image/${msgId}`);
                return response.blob();
              })
              .then(blob => {
                const imgUrl = URL.createObjectURL(blob);

                // Create container div with relative positioning
                const $container = document.createElement('div');
                $container.style.position = 'relative';
                $container.style.display = 'inline-block';
                $container.className = 'imgCard';
                $container.setAttribute('data-id', msgId);

                // Create img element
                const $imgElement = document.createElement('img');
                $imgElement.src = imgUrl;
                $imgElement.style.width = '100%'; // Adjust based on container
                $imgElement.style.paddingBottom = '0.8rem';

                // Create delete button
                const $deleteButton = document.createElement('button');
                $deleteButton.type = 'button';
                $deleteButton.className = 'btn-close delete_message';
                $deleteButton.setAttribute('aria-label', 'Close')
                $deleteButton.setAttribute('data-id', msgId);

                // Append img and button to the container
                $container.appendChild($imgElement);
                $container.appendChild($deleteButton);

                // Add event listner to open original image in a new window
                $container.addEventListener('click', async function() {
                  const originalImageUrl = await fetchOriginalImageUrl(msgId);

                  const img = new Image();
                  img.onload = function() {
                    const width = this.naturalWidth;
                    const height = this.naturalHeight;

                    // Open a new window with the size of the original image
                    const newWindow = window.open('', '_blank', `width=${width}, height=${height}`);
                    newWindow.document.write(`<title>Original Image</title><img src="${originalImageUrl}" style="width:100%;height:100%;object-fit:contain;">`);
                    newWindow.document.close();
                  };
                  img.src = originalImageUrl;
                })

                async function fetchOriginalImageUrl(msgId) {
                  const response = await fetch(_URL + `/textgpt/get_image/${msgId}`);
                  const blob = await response.blob();
                  return URL.createObjectURL(blob);
                }

                // Add event Listener to the delete button
                $deleteButton.addEventListener('click', (event) => {
                  event.stopPropagation();
                  // console.log(`Delete item with ID: ${msgId}`);
                  fetch(_URL + `/textgpt/deleteImage/${msgId}`, { method: 'DELETE' })
                    .then(res => {
                      if (!res.ok) {
                        throw Error(`HTTP error! status: ${res.status}`);
                      }
                      return res.json()
                    })
                    .then(msg => {
                      // 화면상에서 해당 이미지가 담긴 태그를 삭제하는 처리를 수행
                      // Find the div with the matching data-id attribute and remove it
                      const $target = document.querySelector(`div.imgContainer[data-id="${msgId}"]`);
                      if ($target) {
                        $target.remove();
                        e.target.value = '';
                        // console.log(`Item with ID: ${msgId} removed from the DOM`);
                        store.dispatch({ type:'UPDATE', content:'delete_image', imageStr: _URL + `/textgpt/get_image/${msgId}` });
                      } else {
                        console.error("Element not found in the DOM");
                      }
                    });
                });

                // Append container to the thumbnails div
                const $thumbnails = document.getElementById('thumbnails');
                // $thumbnails.appendChild($container);
                $thumbnails.insertBefore($container, $imgSpinner);
              });
          })).then(() => {
            // console.log(imgUrlArray);
            store.dispatch({ type:'UPDATE', content:'add_images', images: imgUrlArray });
          });
        })
        .then(() => {
          $imgSpinner.style.display = 'none';  
        })
        .catch(error => {
          console.error('Error: ', error);
          $imgSpinner.style.display = 'none';
        });
      }
    });

    const toggleButton = document.getElementById("toggleButton");
    const sidebar = document.getElementById("sidebar");
    const chatWindow = document.getElementById("chatWindow");
    const $chatBtn = document.getElementById("chatBtn");
    const $searchInput = document.getElementById("searchInput");
    const $searchBtn = document.getElementById("searchBtn");
    
    toggleButton.addEventListener("click", function () {
      sidebar.classList.toggle("sidebar-hidden");
      chatWindow.classList.toggle("chat-expanded");
      toggleButton.classList.toggle("btn-margin");

      setTimeout(() => {
        $chatBtn.classList.toggle("invisible");
        $searchInput.classList.toggle("invisible");
        $searchBtn.classList.toggle("invisible");
      }, 100);

      const icon = toggleButton.querySelector("i");
      icon.classList.toggle("fa-square-caret-left");
      icon.classList.toggle("fa-square-caret-right");
    });

    const fontIncrease = document.getElementById("fontIncrease");
    const fontDecrease = document.getElementById("fontDecrease");

    // 초기 폰트 크기 설정
    const articles = document.getElementById("article");

    const updateFontSize = () => {
      const textElements = articles.querySelectorAll("*");
      textElements.forEach(el => {
        el.style.fontSize = fontSize + "px";
      });
    };

    fontIncrease.addEventListener("click", function () {
      if (fontSize < 50) {
        fontSize += 2;
        updateFontSize();
      }
    });

    fontDecrease.addEventListener("click", function () {
      if (fontSize > 10) {
        fontSize -= 2;
        updateFontSize();
      }
    });

    const $currentModel = document.getElementById('currentModel');
    const $settingBtn = document.getElementById('settingBtn');
    const $dalleSettingBtn = document.getElementById('dalleSettingBtn');
    $currentModel.addEventListener('mouseenter', () => {
      $currentModel.classList.add('cursor-pointer');
    });

    $currentModel.addEventListener('mouseleave', () => {
      $currentModel.classList.remove('cursor-pointer');
    });

    $currentModel.addEventListener('click', () => {
      const state = store.getState();
      $settingBtn.classList.toggle('modeChange');
      $dalleSettingBtn.classList.toggle('modeChange');
      if ($dalleSettingBtn.classList.contains('modeChange')) {
        const model_name = state.model.replace('gpt', 'GPT');
        $currentModel.textContent = model_name;
      } else {
        $currentModel.textContent = state.dalle_model.toUpperCase();
      }
    });

    // MutationObserver에 사용할 콜백 함수 정의
    const observerCallback = function(mutationsList) {
      const textarea = document.getElementById('myInput');
      const imgLabel = document.getElementById('img-label');
      for (let mutation of mutationsList) {
          if (mutation.type === 'childList' || mutation.type === 'characterData') {
            if ($currentModel.textContent.startsWith('GPT')) {
              // console.log('GPT');
              textarea.setAttribute('maxlength', 5000);
              textarea.setAttribute('minlength', 2);
              if (!textarea.hasAttribute('required')) {
                textarea.setAttribute('required', '');
              }
              textarea.setAttribute('placeholder', '프롬프트를 입력해 주세요');
              imgLabel.style.display = 'block';
            } else if ($currentModel.textContent === 'DALL-E-2') {
              // console.log('DALL-E-2');
              textarea.setAttribute('maxlength', 1000);
              textarea.removeAttribute('minlength');
              if (textarea.hasAttribute('required')) {
                textarea.removeAttribute('required');
              } 
              textarea.setAttribute('placeholder', '이미지 생성 및 편집, 변환 등을 위한 프롬프트를 영어로 입력해 주세요');
              imgLabel.style.display = 'block';
            } else if ($currentModel.textContent === 'DALL-E-3') {
              // console.log('DALL-E-3');
              textarea.setAttribute('maxlength', 4000);
              textarea.setAttribute('minlength', 2);
              if (!textarea.hasAttribute('required')) {
                textarea.setAttribute('required', '');
              }
              textarea.setAttribute('placeholder', '이미지 생성을 위한 프롬프트를 입력해 주세요');
              imgLabel.style.display = 'none';
              const $thumbnails = document.getElementById('thumbnails');
              const children = $thumbnails.children;
              while (children.length > 1) {
                $thumbnails.removeChild(children[0]);
              }
              const $imgInput = document.getElementById('img');
              $imgInput.value = '';
            }
          }
      }
    };

    // MutationObserver 생성
    const observer = new MutationObserver(observerCallback);

    // 대상 노드와 옵션 설정
    observer.observe(currentModel, {
      childList: true,   // 자식 요소의 추가 또는 삭제 감지
      characterData: true // 텍스트 내용의 변화 감지
    });
  }
</script>
{% endblock %}