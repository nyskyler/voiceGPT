{% extends "base3.html" %}
{% block content %}
<style>
  #myRow {
    display: flex;
    flex-direction: row;
  }
  #sidebar {
    display: flex;
    flex-direction: column;
    flex: auto;
    height: 94vh;
    border-right: 1px solid #DDDDDD;
    transform: translateX(0); /* 기본 위치 */
    transition: transform 0.5s ease, width 0.5s ease; /* 슬라이드 애니메이션 */
    padding: 0px; 
    margin: 0 auto;
  }
  #nav_dir, #nav_dir_modal {
    flex: auto;
    padding: 1rem;
    overflow-y: auto;
    background-color: #F6F7FA;
  }
  #toc, #toc_modal {
    white-space: nowrap; /* 줄 바꿈 방지 */
    overflow-x: auto;    /* 가로 스크롤 표시 */
    display: block;      /* ul 기본 블록 요소로 설정 */
  }
  #toc li, #toc_modal li {
    display: inline-block; /* 목록 항목을 인라인 블록으로 설정하여 한 줄에 표시 */
  }
  #nav_dir .list-group-item, #nav_dir_modal .list-group-item {
    border: none;
    background-color: #F6F7FA;
    font-size: 0.85rem;
    padding-top: 0.2rem;
    padding-bottom: 0.2rem;
  }
  #storage_info {
    padding: 0.6rem 1rem 1rem 1rem;
    border-top: 1px solid #DDDDDD;
    background-color: #F6F7FA;
    /* 기본 높이만 차지 */
    /* flex-shrink: 0; */
  }

  #storage_info span {
    font-size: 0.8rem;
  }
  #toc_modal {
    max-height: 400px;
    overflow: auto;
  }
  #nav_files {
    display: flex;
    flex-direction: column;
    flex: auto;
    height: 94vh;
    transition: flex 0.5s ease; /* 슬라이드 애니메이션 */
  }
  .sidebar-hidden {
    transform: translateX(-100%);
    transition: transform 0.5s ease, width 0.5s ease;
    width: 0%;
    padding: 0px;
  }
  .nav_files_expanded {
    flex-grow: 1; /* 부모 너비를 기준으로 남은 공간 채우기 */
    transition: flex-grow 0.5s ease;
  }
  .btn-file, .btn-folder {
    margin-left: 0.2rem; 
    padding: 0.2rem 0.6rem 0.3rem 0.6rem;
    background-color: #F1F3F9; 
  }
  .btn-file:hover, .btn-folder:hover {
    background-color: #D1D1D1; 
  }
  button span {
    font-size: 0.8rem; 
    font-weight: bold; 
  }
  .dropdown-menu {
    min-width: auto !important;  /* 기본 너비 제한 해제 */
    width: fit-content !important; /* 내용에 맞게 자동 조정 */
  }

  #file_list {
    display: flex;
    flex-direction: row;
    flex: auto;
    overflow-y: auto;
    padding: 1rem;
  }
  #placeholder {
    flex: auto;
  }
  #my_table {
    flex: auto;
    min-width: 600px;
    overflow-y: auto;
    padding-left: 0.3rem;
    padding-right: 0.3rem;
  }
  #my_table.invisible {
    display: none;
  }
  #my_grid {
    flex: auto;
    min-width: 600px;
    overflow-y: auto;
  }
  #my_grid.invisible {
    display: none;
  }
  #right_panel {
    display: flex;
    flex-direction: column;
    width: 350px;
    min-width: 300px;
    height: 100%;
    border-left: 1px solid #DDDDDD;
    padding: 1rem; 
  }
  #right_panel.hidden {
    /* width: 0%; */
    display: none;
  }
  .invisible {
    display: none;
  }
  .currentMode {
    color: #4078FF !important; 
  }
  #toggleAllCheckboxId {
    font-size: 1.2rem;
  }
  .table-hover td, .table-hover th {
    white-space: nowrap;
  }
  .flex-grow {
    width: 100%;
    white-space: normal;
    font-size: 0.9rem;
  }
  .table thead th {
    position: sticky;
    top: 0;
    background-color: white; /* 헤더 배경색 설정 */
    z-index: 1; /* 다른 콘텐츠보다 위에 표시되도록 설정 */
    font-weight: normal;
    font-size: 0.7rem;
    color: #767780;
  }
  .table tr .mobile {
    color: #9398A0;
    font-size: 0.8rem;
    font-weight: normal;
  }
  tbody#rp_text_info tr td {
    border: none !important;
  }
  span#rp_title {
    word-break: break-word;  /* 긴 단어를 적절히 줄바꿈 */
    white-space: normal;
  }
  td.td_key {
    color: #767780;
    white-space: nowrap;
    font-weight: normal;
    font-size: 0.8rem;
  }
  td.td_value {
    color: black;
    font-weight: normal;
    font-size: 0.8rem;
    word-break: break-word;  /* 긴 단어를 적절히 줄바꿈 */
    white-space: normal;
  }
  #table_body td.file,
  #table_body td.directory {
    word-break: break-word;  /* 긴 단어를 적절히 줄바꿈 */
    white-space: normal;    /* 텍스트가 줄 바꿈을 허용 */
  }
  #grid_content {
    display: flex;         /* Flexbox 레이아웃 사용 */
    flex-flow: row wrap;    /* 줄바꿈 허용 */
    justify-content: flex-start;
    padding: 3rem;
    gap: 1rem;             /* 요소 간격 설정 */
  }
  #grid_content i {
    font-size: 4.5rem;
    padding: 2.5rem;
  }
  #grid_content p, #progressDiv p {
    white-space: nowrap;
    overflow: hidden; 
    text-overflow: ellipsis;
    margin: 0;
  }
  #grid_content .card-body {
    padding: 0px;
  }
  #grid_content .card span.hidden {
    display: none;
  }
  .form-check-input:focus, #shareLink:focus {
    box-shadow: none;
  }
  #home {
    margin-left: 1rem;
  }
  #breadcrumb li {
    cursor: pointer;
  }
  #banner {
    flex: 0 0 auto;
    /* padding-top: 0.9rem;
    padding-bottom: 0.5rem; */
    border-bottom: 1px solid #DDDDDD;
  }
  #top_banner {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding-top: 0.6rem;
  }
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    /* padding: 0 10px; */
  }
  .cursor-pointer {
    cursor: pointer; /* 포인터 모양으로 변경 */
  }
  #toggleButton {
    display: none;
  }
  /* Toggle Button */
  .toggle-btn {
    border: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    outline: none;
    margin-right: 0.3rem;
  }
  .toggle-btn i {
    font-size: 1.2rem;
  }
  .btn-margin {
    margin-left: 0.8rem;
  }
  #searchInput:focus, #searchInput2:focus, #topicInput:focus {
    outline: none;
    box-shadow: none;
    border-color: black;
  }
  .btn-transparent {
    background-color: transparent;
    border: none;
  }
  .btn-transparent:hover {
    background-color: rgba(0, 0, 0, 0.1); /* 호버 시 배경색 추가 (선택 사항) */
  }

  @media (min-width: 1024px) and (max-width: 1366px) {
  /* 아이패드 프로 12.9인치 화면에만 적용할 스타일 */
    #sidebar {
      height: 94vh;
    }
    #nav_dir {
      height: 86vh;
    }
    #nav_files {
      height: 94vh;
    }
  } 

  @media (max-width: 767.98px) and (orientation: portrait) {
    #nav_files {
      height:92vh; /* 모바일에서는 전체 화면 높이로 설정 */
    }
    .toggle-btn {
      display: none;
    }
    #fontIncrease, #fontDecrease {
      display: none;
    }
    #sidebar {
      display: none;
    }
    .mobile {
      display: none;
    }
    #my_table {
      min-width: 300px;
    }
    #my_grid {
      min-width: 300px;
    }
    #right_panel, #infoToggleBtn {
      display: none;
    }
    form#searchForm {
      display: none !important;
    }
    #toggleButton {
      display: inline-block;
    }
    #home {
      margin-left: 0rem;
    }
    #grid_content {
     padding: 1.8rem;
  }
  }
</style>
<!-- Password Modal -->
<div class="modal" id="passwordModal" tabindex="-1" role="dialog">
  <div class="modal-dialog" role="document">
    <div class="modal-content">
    <div class="modal-header">
      <h5 id="modalTitle" class="modal-title fs-2" style="color: #4078FF;"><i class="fa-solid fa-lock"></i></h5>
    </div>
    <div class="modal-body" style="text-align: center;">
      <p>공유 링크가 암호로 보호되어 있습니다.<br> 확인하려면 암호를 입력하세요.</p>
      <input type="password" id="passwordInput" class="form-control">
    </div>
    <div class="modal-footer">
      <button type="button" id="submitPassword" class="btn btn-primary">확인</button>
    </div>
    </div>
  </div>
</div>
<div id="basePath" style="display: none;">{{ base_path }}</div>
<div class="container-fluid">
  <div id="myRow" class="row">
    <div id="nav_files" class="col-12 col-md-10 p-0">
      <div id="top_banner" style="display: flex; align-items: center;">
        <div style="display: inline-block;">
          <nav class="fs-5" style="--bs-breadcrumb-divider: url(&#34;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8'%3E%3Cpath d='M2.5 0L1 1.5 3.5 4 1 6.5 2.5 8l4-4-4-4z' fill='%236c757d'/%3E%3C/svg%3E&#34;); display: inline-block;" aria-label="breadcrumb">
            <ol id="breadcrumb" class="breadcrumb">
            </ol>
          </nav>
        </div>
      </div>
      <div id="banner">
        <div class="header">
          <span>
            <button id="toggleAllCheckboxId" class="btn btn-transparent"><i class="fa-regular fa-square" style="color: #DEE2E6;"></i></button>
            {% if edit %}
            <span class="dropdown">
              <button id="uploadBtn" class="btn btn-transparent" data-bs-toggle="dropdown" type="button" data-bs-toggle="dropdown" aria-expanded="false" style="background-color: #4078FF; padding: 0.2rem 0.6rem 0.3rem 0.6rem;"><i class="fa-solid fa-arrow-up-from-bracket" style="font-size: 0.9rem;  color: white;"></i><span style="color: white;"> 올리기</span></button>
              <ul class="dropdown-menu">
                <li><button id="fileUploadBtn" class="dropdown-item" type="button" style="font-size: 0.9rem; text-align: center;"><label id="file-label" for="inputFiles">파일 올리기</label></button></li>
                <input id="inputFiles" type="file" accept="*/*" style="display:none" multiple>
                <li><button id="folderUploadBtn" class="dropdown-item" type="button" style="font-size: 0.9rem; text-align: center;"><label id="folder-label" for="inputFolder">폴더 올리기</label></button></li>
                <input id="inputFolder" type="file" webkitdirectory directory multiple style="display: none;">
              </ul>
            </span>
            {% endif %}
            <span id="btnFiles" class="invisible">
              <button id="downloadBtn" class="btn btn-file"><span>내려받기</span></button>
              </span>
            </span>
            <span>
            <button id="tableBtn" class="btn btn-transparent currentMode"><i class="fa-solid fa-bars"></i></button>
            <button id="gridBtn" class="btn btn-transparent"><i class="fa-solid fa-grip"></i></button>
            <button id="infoToggleBtn" class="btn btn-transparent"><i class="fa-solid fa-circle-info" style="color: #4078FF;"></i></button>
            </span>
          </span>
        </div>
        <!-- 📌 다운로드 진행률 바 -->
        <div id="progressDiv" class="invisible" style="width: 100%; background: #ddd; border-radius: 5px; margin-top: 10px;">
          <p style="font-size: 0.8rem; text-align: center;"></p>
          <div id="downloadProgress" style="
            width: 0%;
            height: 1.2rem;
            font-size: 0.8rem;
            background: #4078FF;
            text-align: center;
            /* line-height: 25px; */
            line-height: normal;
            color: white;
            border-radius: 2px;">
            0%
          </div>
          <div id="downloadProgress2" style="
            width: 0%;
            height: 1.2rem;
            font-size: 0.8rem;
            background: #FF6347;
            text-align: center;
            /* line-height: 25px; */
            line-height: normal;
            color: white;
            border-radius: 2px;">
            0%
          </div>
        </div>
      </div>
      <div id="file_list" style="padding: 0px;">
        <div id="placeholder" class="invisible text-center flex-column align-items-center justify-content-start" style="margin-top: 5rem;">
          <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="placeholder-glow fs-5 mb-3">
            <span class="placeholder col-8"></span>
          </p>
          <div class="d-flex gap-3">
            <div class="placeholder-glow">
              <div class="placeholder rounded bg-warning" style="width: 80px; height: 80px;"></div>
            </div>
            <div class="placeholder-glow">
              <div class="placeholder rounded bg-primary" style="width: 80px; height: 80px;"></div>
            </div>
            <div class="placeholder-glow">
              <div class="placeholder rounded bg-secondary" style="width: 80px; height: 80px;"></div>
            </div>
          </div>
          <p class="mt-4 text-muted">데이터를 불러오는 중입니다... 잠시만 기다려 주세요.</p>
        </div>
        <div id="my_table">
          <table class="table table-hover">
            <thead>
              <tr id="table_header">
              </tr>
            </thead>
            <tbody id="table_body">
            </tbody>
          </table>
        </div>
        <div id="my_grid" class="invisible">
          <div id="grid_content">
          </div> 
        </div>
        <div id="right_panel">
          <div id="rp_header" class="fs-5">
            <span id="rp_title" class="fw-semibold"></span>
          </div>
          <div id="rp_thumb"></div>
          <table class="table">
            <tbody id="rp_text_info">
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}
{% block script %}
<script type="module">
  document.addEventListener("DOMContentLoaded", function() {
    var password = "{{ password }}"; // This is passed from Flask

    if (!password) {
      return
    }
    // Show the password modal on page load
    var modal = new bootstrap.Modal(document.getElementById('passwordModal'), {
      backdrop: 'static',
      keyboard: false
    });
    modal.show();

    document.getElementById("submitPassword").addEventListener("click", function() {
      var inputPassword = document.getElementById("passwordInput").value;

      if (inputPassword === password) {
        // If password matches, close the modal and allow access
        // modalTitle
        document.getElementById('modalTitle').innerHTML = `<i class="fa-solid fa-lock-open"></i>`;
        setTimeout(() => {
          modal.hide();
        }, 1000);
      } else {
        // Wrong password, show an error message
        alert("비밀번호가 틀렸습니다. 다시 시도해 주세요.");
      }
    });
  });
  import { createStore } from 'https://cdnjs.cloudflare.com/ajax/libs/redux/5.0.1/redux.legacy-esm.js';

  // 'invisible' 클래스를 토글하는 함수
  function toggleVisibility(item, isInvisible) {
    if (isInvisible) {
      item.classList.add('invisible');
      const icon = item.querySelector('.fa-solid');
      if (icon && icon.classList.contains('fa-folder-open')) {
        icon.classList.remove('fa-folder-open');
        icon.classList.add('fa-folder');
        item.classList.remove('open');
      }
    } else {
      item.classList.remove('invisible');
    }
  }

  // 아이콘을 변경하는 함수
  function toggleFolderIcon(item, isOpen) {
    const icon = item.querySelector('.fa-solid');
    if (icon) {
      if (isOpen) {
        icon.classList.remove('fa-folder');
        icon.classList.add('fa-folder-open');
      } else {
        icon.classList.remove('fa-folder-open');
        icon.classList.add('fa-folder');
      }
    }
  }

  // 하위 아이템을 숨기거나 표시하는 함수
  function handleSubItems(item, shouldDisplay) {
    const targetIds = JSON.parse(item.dataset.subids);
    targetIds.forEach(id => {
      const subItem = document.querySelector(`.list-group-item[data-id='${id}']`);
      if (subItem) {
        toggleVisibility(subItem, shouldDisplay);
        // 하위 항목이 토글되었으면, 그 하위 아이템의 subids도 처리
        if (shouldDisplay) {
          handleSubItems(subItem, shouldDisplay);
        }
      }
    });
  }

  function getStyledDirectoryName(d_path, depth, path) {
    return '&emsp;'.repeat(depth) + '<i class="fa-solid fa-folder" style="color: #4078FF;"></i>' + '&emsp;' + d_path; 
  }

  const icons = {
    'folder': '<i class="fa-solid fa-folder" style="color: #4078FF;"></i>',
    'pdf': '<i class="fa-solid fa-file-pdf" style="color: #DA5A37"></i>',
    'zip': '<i class="fa-solid fa-file-zipper" style="color: #968069"></i>',
    'doc': '<i class="fa-solid fa-file-word" style="color: #457DD8"></i>',
    'docx': '<i class="fa-solid fa-file-word" style="color: #457DD8"></i>',
    'ppt': '<i class="fa-solid fa-file-powerpoint" style="color: #E76C4E"></i>',
    'pptx': '<i class="fa-solid fa-file-powerpoint" style="color: #E76C4E"></i>',
    'xls': '<i class="fa-solid fa-file-excel" style="color: #30A364"></i>',
    'xlsx': '<i class="fa-solid fa-file-excel" style="color: #30A364"></i>',
    'hwp': '<i class="fa-solid fa-file-signature" style="color: #43A6DD"></i>',
    'hwpx': '<i class="fa-solid fa-file-signature" style="color: #43A6DD"></i>',
    'video': '<i class="fa-solid fa-file-video" style="color: #01C75A"></i>',
    'mp3': '<i class="fa-solid fa-file-audio" style="color: #6F42C1"></i>',
    'webm': '<i class="fa-solid fa-file-audio" style="color: #6F42C1"></i>',
    'aac': '<i class="fa-solid fa-file-audio" style="color: #6F42C1"></i>',
    'm4a': '<i class="fa-solid fa-file-audio" style="color: #6F42C1"></i>',
    'wav': '<i class="fa-solid fa-file-audio" style="color: #6F42C1"></i>',
    'flac': '<i class="fa-solid fa-file-audio" style="color: #6F42C1"></i>',
    'html': '<i class="fa-solid fa-file-code" style="color: #1DB45B"></i>',
  }

  function getFileExtensionIcon(_ext, thumbnail=false, grid=false) {
    if (_ext === 'Directory') {
      return '<i class="fa-solid fa-folder" style="color: #4078FF;"></i>';
    } else if (thumbnail && grid) {
      return `
      <div class="spinner-border text-info" style="width: 3rem; height: 3rem; margin: 2rem; role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      `;
    } else if (thumbnail && !grid) {
      return `
      <div class="spinner-border spinner-border-sm text-info" role="status">
        <span class="visually-hidden">Loading...</span>
      </div>
      `;  
    } else {
      const ext = _ext.split('.')[1].toLowerCase();
      let tag = icons[ext] || `<i class="fa-regular fa-file"></i>`;
      return tag;
    }
  }

  function convertBytesToReadableUnit(sizeBytes) {
    let size;
    if (sizeBytes < 1_000_000) {  // Less than 1 MB
      size = `${(sizeBytes / 1_024).toFixed(1)}KB`;
    } else if (sizeBytes < 1_073_741_824) {  // Less than 1 GB (1_073_741_824 bytes = 1 GB)
      size = `${(sizeBytes / 1_048_576).toFixed(1)}MB`;
    } else {  // 1 GB or more
      size = `${(sizeBytes / 1_073_741_824).toFixed(2)}GB`;
    }
    return size;
  }

  function initializeTableHeader() {
    const $table_header = document.getElementById('table_header');
    const $ths = $table_header.querySelectorAll('th');
    $ths.forEach(th => {
      th.remove();
    });
    $table_header.innerHTML = `
      <th scope="col">   </th>
      <th scope="col" data-id="type">종류 </th>
      <th scope="col" data-id="name" class="flex-grow">이름 </th>
      <th scope="col" data-id="size" class="mobile">크기 </th>
      <th scope="col" data-id="date" class="mobile">수정한 날짜 </th>
    `;  

    const ths = document.querySelectorAll('#table_header th');
    ths.forEach((th, idx) => {
      if (idx == 0) {
        return;
      }
      th.addEventListener('click', () => {
        const $elem = document.querySelector('th i');
        if ($elem) {
          $elem.remove();
        }
  
        th.classList.toggle('oddEvenToggle');
        // console.log(th);
        const oddEven = th.classList.contains('oddEvenToggle') ? 'odd' : 'even';
        const $iconEl = document.createElement('i');
        $iconEl.classList.add('fa-solid');
        oddEven == 'odd' ? $iconEl.classList.add('fa-arrow-up') : $iconEl.classList.add('fa-arrow-down');
        // console.log(oddEven);
        th.appendChild($iconEl);
        store.dispatch({ type: 'UPDATE', target: 'sort_table', rule: th.dataset.id, count: oddEven });
      });
    });
  }

  const fetchItemThumbnailAndDetails = async (item_path) => {
    // fetch를 사용하여 서버에서 이미지를 가져오고, Blob과 URL.createObjectURL을 사용하여 이미지를 웹 페이지에 표시하기
    const state = store.getState();
    const url = `${_URL}/cloudstorage/getThumbnailAndDetails/${item_path.slice(1).trim()}`;
    try {
      const response = await fetch(url, { method: 'GET' });
      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      if (response.status === 204) {
        console.log('No Content');
        return;
      }

      const $thumbnail = document.getElementById('rp_thumb');
      const $rp_text_info = document.getElementById('rp_text_info');
      $thumbnail.innerHTML = '';
      $rp_text_info.innerHTML = '';
      const res = await response.json();
      // console.log(res.info);
      const mediaTypesForThumbnails = ['pdf', 'image', 'video'];

      if (mediaTypesForThumbnails.includes(res.type)) {
        const thumbnailBase64 = res.data;
        const imageUrl = `data:image/png;base64,${thumbnailBase64}`;
        const $imgElement = document.createElement('img');
        $imgElement.src = imageUrl;
        $imgElement.style.width = '100%'; // Adjust based on container
        $imgElement.style.paddingTop = '0.8rem';
        $imgElement.style.paddingBottom = '0.8rem';
        $thumbnail.appendChild($imgElement);
      } else {
        const $divElement = document.createElement('div');
        $divElement.innerHTML = icons[res.type] || '<i class="fa-regular fa-file"></i>';
        $divElement.style.width = '100%'; // Adjust based on container
        $divElement.style.textAlign = 'center'
        $divElement.style.fontSize = '6rem';
        $divElement.style.paddingTop = '0.8rem';
        $divElement.style.paddingBottom = '0.8rem';
        $divElement.style.backgroundColor = '#F5F6F9';
        $thumbnail.appendChild($divElement);
      }
      
      const $fragment = document.createDocumentFragment();

      Object.entries(res.info).forEach(item => {
        const $tr = document.createElement('tr');
        const $td_for_key = document.createElement('td');
        $td_for_key.classList.add('td_key');
        const $td_for_value = document.createElement('td');
        $td_for_value.classList.add('td_value');
        $td_for_key.textContent = item[0];
        $td_for_value.textContent = (item[1] == '/Users/yuseung-u/Desktop/pythonLab/voiceGPT' ? '/' : item[1]);
        // if (res.type == 'folder' && item[0] == '위치') {
        //   document.getElementById('rp_title').textContent = $td_for_value.textContent;
        // }
        $tr.appendChild($td_for_key);
        $tr.appendChild($td_for_value);
        $fragment.appendChild($tr);
      });
      $rp_text_info.appendChild($fragment);
    } catch (error) {
      console.error('Error:', error);
    }
  }

  async function generateThumbnailOrIconTag(_type, filePath, _thumbnail, _size=25, card=false) {
    if (_type == 'Directory') {
      return '<i class="fa-solid fa-folder" style="color: #4078FF;"></i>';
    } else if (_thumbnail === 'image' || _thumbnail === 'video') {
      try {
        const url = `${_URL}/cloudstorage/generateThumbnail/`;
        const data = { 
          path: filePath,
          type: _thumbnail,
          size: _size,
        };

        const options = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        };

        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`Failed to get thumbnail for ${filePath}`);
        }
        const res = await response.json();
        // console.log(res.message);
        const imageUrl = `data:image/png;base64,${res.message}`;
        return `<img src=${imageUrl} style="width:${_size}px; height:${_size}" padding:2px; text-align: center; ${card ? 'class="card-img-top" alt="..."' : ''}></img>`;
      } catch (error) {
        console.error('Error:', error);
      }
    } else {
      return getFileExtensionIcon(_type);
    }
  }

  function toggleElementVisibilityById(tag, hidden) {
    const flag = $(tag).hasClass('invisible');
    if (hidden && !flag) {  // 태그를 숨기고자 할 경우
      $(tag).addClass('invisible');
    } else if (!hidden && flag) { // 태그를 보이고자 할 경우
      $(tag).removeClass('invisible');
    }
  }

  function updateButtonIconBasedOnCheckboxes() { // 다른 체크박스 요소들이 체크되어 있는지 확인하여, 그 결과에 따라 특정 버튼 요소의 아이콘 모양을 바꿔주는 함수
    const state = store.getState();
    const { view_contents, selectedItems, directoryTree, checkedFilePathsForMove, checkedFilePathsForCopy } = state;
    const $toggleAllCheckboxId = document.getElementById('toggleAllCheckboxId');
    const $compressBtn = document.getElementById('compressBtn');
    const $extractBtn = document.getElementById('extractBtn');
    const $pasteBtn = document.getElementById('pasteBtn');
    const $shareLinkBtn = document.getElementById('shareLinkBtn');
    const $divider = document.getElementById('_divider');

    if (selectedItems.length == 0) {
      $toggleAllCheckboxId.innerHTML = '<i class="fa-regular fa-square" style="color: #DEE2E6;"></i>';
      toggleElementVisibilityById('#btnFiles', true);
      toggleElementVisibilityById('#newfolderBtn', false);
    } else if (selectedItems && (selectedItems.length == view_contents.length)) {
      $toggleAllCheckboxId.innerHTML = '<i class="fa-solid fa-square-check" style="color: #4078FF;"></i>';
      toggleElementVisibilityById('#btnFiles', false);
      toggleElementVisibilityById('#newfolderBtn', true);
    } else {
      $toggleAllCheckboxId.innerHTML = '<i class="fa-solid fa-square-minus" style="color: #4078FF;"></i>';
      toggleElementVisibilityById('#btnFiles', false);
      toggleElementVisibilityById('#newfolderBtn', true);
    }

    const showPasteBtn = (checkedFilePathsForMove.length > 0 && selectedItems.length == 0) || (checkedFilePathsForCopy.length > 0 && selectedItems.length == 0)? false : true;    
  }

  function openFile(filename, isVideo = false, isAudio = false) {
    const url = `${_URL}/cloudstorage/view/${filename}`;
    
    if (isVideo) {
      // 동영상 플레이어 창 열기
        const videoPage = `
        <html>
          <head><title>동영상 플레이어</title></head>
          <body style="margin:0; overflow:hidden;">
            <video id="videoPlayer" controls autoplay style="width: 100%; height: 100vh;">
              <source src="${url}" type="video/mp4">
              브라우저가 비디오 태그를 지원하지 않습니다.
            </video>
            <script>
              document.addEventListener('DOMContentLoaded', function () {
                const video = document.getElementById('videoPlayer');
                video.requestFullscreen?.();
              });
          </body>
        </html>`;
      const videoWindow = window.open("", "_blank");
      videoWindow.document.write(videoPage);
    } else if (isAudio) {
      // 오디오 플레이어 창 열기
      const audioPage = `
        <html>
          <head><title>오디오 플레이어</title></head>
          <body>
            <audio controls autoplay style="width: 100%;">
              <source src="${url}" type="audio/${filename.split('.').pop()}">
              브라우저가 오디오 태그를 지원하지 않습니다.
            </audio>
          </body>
        </html>`;
      
      const audioWindow = window.open("", "_blank");
      audioWindow.document.write(audioPage);
    } else {
      // 일반 파일 열기
      window.open(url, '_blank');
    }
  }

  let reloadingFlag_for_article = true;

  async function article() {
    const state = store.getState();
    const { current_path, selectedItems, checkedFilePathsForMove } = state;
    const selected = selectedItems.map(item => item.split('/').pop());

    if (!reloadingFlag_for_article) {
      document.querySelectorAll('#table_body input.form-check-input').forEach(elem => {
        selected.includes(elem.value) ? elem.checked = true : elem.checked = false;
      });
      return
    }
    
    // ⏳ 1. 일단 테이블을 기본 아이콘으로 렌더링
    const htmlArray = state.view_contents.map(({ _type, _name, _size, _loc, _modified, _thumbnail, _link }) => {
      const isChecked = selected.includes(_name);
      const popoverContent = _loc ? `data-bs-toggle="popover" data-bs-title="위치" data-bs-content="${_loc}"` : '';
      
      // 기본 아이콘 사용 (썸네일이 아직 로드되지 않았기 때문)
      const defaultIcon = getFileExtensionIcon(_type, _thumbnail, false);

      return `<tr data-name="${_name}">
        <td><input class="form-check-input" type="checkbox" data-loc="${_loc}" data-type="${_type == 'Directory' ? 'directory' : 'file'}" value="${_name}" ${isChecked ? "checked" : ""} aria-label="..."></td>
        <td class="thumbnail-container ${_loc ? 'popover-hover' : ''}" ${popoverContent}>${defaultIcon}</td>
        <td class="flex-grow ${_type == 'Directory' ? 'directory' : 'file'}" data-loc="${_loc}" style="${checkedFilePathsForMove?.includes(current_path.slice(1) + '/' + _name) ? 'color: #9CA1A8;' : ''}">${_name}${_link ? '&ensp;<button type="button" class="btn btn-sm btn-outline-secondary shareLink" style="padding: 0px 3px 0px 3px;"><i class="fa-solid fa-link" style="font-size: 0.7rem;"></i></button>' : ''}</td>
        <td class="mobile">${convertBytesToReadableUnit(_size)}</td>
        <td class="mobile">${_modified}</td>
      </tr>`;
    });

    document.getElementById('table_body').innerHTML = htmlArray.join('');

    // ⏳ 2. 비동기적으로 썸네일 가져와서 개별 업데이트
    state.view_contents.forEach(async ({ _type, _name, _loc, _thumbnail }) => {
      if (_thumbnail === 'image' || _thumbnail === 'video') {
        const thumbnailTag = await generateThumbnailOrIconTag(_type, `${_loc && _type !== 'Directory' ? _loc + '/' + _name : current_path + '/' + _name}`, _thumbnail, 25, false);
        // 해당 파일의 썸네일 `<td>` 업데이트
        const row = document.querySelector(`tr[data-name="${_name}"] .thumbnail-container`);
        if (row) row.innerHTML = thumbnailTag;
      }
    });

    document.querySelectorAll('#table_body td.popover-hover').forEach(td => {
      let popover = new bootstrap.Popover(td, {
        trigger: "manual",
        placement: "left",
      });

      let hideTimeout;

      td.addEventListener("mouseenter", () => {
        clearTimeout(hideTimeout);
        popover.show();
      });

      td.addEventListener("mouseleave", () => {
        hideTimeout = setTimeout(() => {
          popover.hide();
        }, 100); // 팝오버가 사라지기 전 100ms 지연
      });

      td.addEventListener("click", () => {
        popover.hide(); // 팝오버를 수동으로 숨기기
      });
    });

    const dir_tds = document.querySelectorAll('#table_body td.directory');
    dir_tds.forEach(td => {
      td.addEventListener('click', async (e) => {
        e.stopPropagation();
        allowSubscriptionCall = true;
        
        let targetPath = null;
        const loc = e.target.dataset.loc;
        if (loc == 'undefined') {
          targetPath = `${current_path == '/' ? '' : current_path}/${td.textContent.trim()}`; 
        } else {
          targetPath = loc || '';
        }
        toc_flag = false;
        await fetchDirectoryDetails(targetPath);
        toc_flag = true;
      });
    });

    const file_tds = document.querySelectorAll('#table_body td.file');
    file_tds.forEach(td => {
      td.addEventListener('click', async (e) => {
        e.stopPropagation();
        let currentPath = null;
        // allowSubscriptionCall = true;
        const loc = e.target.dataset.loc;
        currentPath = current_path.startsWith('/') ? current_path.slice(1) : current_path;
        currentPath = loc == 'undefined' ? current_path : `${loc.endsWith('/') ? loc.substring(0, loc.length - 1) : loc}`;

        const filename = td.textContent;
        const file_ext = filename.includes('.') ? filename.split('.').pop() : undefined;
        const image_exts = ['png', 'jpeg', 'jpg', 'gif', 'bmp', 'tiff', 'webp'];
        const video_exts = ['mp4', 'avi', 'mov', 'mkv', 'wmv', 'flv'];
        const audio_exts = ['mp3', 'aac', 'm4a', 'ogg', 'wav', 'flac', 'webm'];
        const code_exts = ['html', 'css', 'js', 'py'];
        const office_exts = ['hwp', 'hwpx', 'pdf'];
        // console.log(file_ext);
        if (video_exts.includes(file_ext)) {
          openFile(`${currentPath}/${filename}`, true, false);
        } else if (audio_exts.includes(file_ext)) {
          openFile(`${currentPath}/${filename}`, false, true);  // 비디오 파일
        } else if (image_exts.includes(file_ext) || code_exts.includes(file_ext) || office_exts.includes(file_ext)) {
          openFile(`${currentPath}/${filename}`);
        } 
      });
    });

    // 각 체크박스에 이벤트 리스너 추가
    const checkboxes = document.querySelectorAll('#table_body .form-check-input');
    checkboxes.forEach(checkbox => {
      const row = checkbox.closest('tr');
      if (checkbox.checked) {
        row.classList.add('table-active');
      }
      checkbox.addEventListener('change', (event) => {
        event.stopPropagation();
        row.classList.add('table-active');
        const nameTd = row.querySelector('td:nth-child(3)');
        let targetFullPath = null;

        if (nameTd.dataset.loc === 'undefined') {
          targetFullPath = (current_path === '/' ? '' : current_path) + '/' + nameTd.textContent.trim();
        } else if (nameTd.dataset.loc.endsWith('/')) { // 폴더
          targetFullPath = nameTd.dataset.loc + nameTd.textContent.trim(); 
        } else { // 파일
          targetFullPath = nameTd.dataset.loc.trim();
        }

        targetFullPath = targetFullPath.startsWith('/') ? targetFullPath : '/' + targetFullPath;
        // console.log(targetFullPath);

        if (event.target.checked) { // 체크 상태인 경우에만 실행
          document.getElementById('rp_title').textContent = nameTd.textContent;
          fetchItemThumbnailAndDetails(targetFullPath);
          store.dispatch({ type: "ADD_SELECTED_ITEM", payload: targetFullPath });
        } else { // 체크 해제된 경우
          row.classList.remove('table-active');
          store.dispatch({ type: "REMOVE_SELECTED_ITEM", payload: targetFullPath });
        }
      });
    });

    document.querySelectorAll('button.shareLink').forEach(link => {
      link.addEventListener('click', (e) => {
        event.stopPropagation();
        const { current_path } = store.getState();
        $('#shared_dir_link').text(current_path + '/' + event.target.closest('td').textContent.trim());
        $('#createLinkBtnForModal').click();
      });
    });

    reloadingFlag_for_article = false;
  }

  let reloadingFlag_for_grid = true;

  function grid_article() {
    const { current_path, selectedItems, view_contents } = store.getState();
    const selected = selectedItems.map(item => item.split('/').pop());

    if (!reloadingFlag_for_grid) {
      document.querySelectorAll('#grid_content input.form-check-input').forEach(elem => {
        if (selected.includes(elem.value)) {
          elem.checked = true;

          // 🔥 mouseover 이벤트 인위적으로 발생
          const mouseOverEvent = new MouseEvent('mouseover', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          elem.dispatchEvent(mouseOverEvent);

        } else {
          elem.checked = false;

          // ❌ mouseout 이벤트 인위적으로 발생
          const mouseOutEvent = new MouseEvent('mouseout', {
            bubbles: true,
            cancelable: true,
            view: window
          });
          elem.dispatchEvent(mouseOutEvent);
        }
      });
      return;
    }

    // ⏳ 1. 기본 아이콘으로 먼저 렌더링
    const htmlArray = view_contents.map(({ _type, _name, _loc, _size, _thumbnail, _link }) => {
      const isChecked = selected.includes(_name);
      const popoverContent = _loc ? `data-bs-toggle="popover" data-bs-title="위치" data-bs-content="${_loc}"` : '';

      // 기본 아이콘 사용 (썸네일을 비동기적으로 불러오기 때문)
      const defaultIcon = getFileExtensionIcon(_type, _thumbnail, true);

      return `
      <div class="card mb-5 text-center ${_type == 'Directory' ? 'directory' : 'file'}" data-name="${_name}" data-loc="${_loc}" style="width: 150px; height: 150px; position: relative;">
        <div class="thumbnail-container">${defaultIcon}</div>
        <span class="hidden" style="position: absolute; top: 5px; left: 5px;">
          <input class="form-check-input" type="checkbox" data-loc="${_loc}" data-type="${_type == 'Directory' ? 'directory' : 'file'}" value="${_name}" ${isChecked ? "checked" : ""} aria-label="..."> 
        </span>
        <span style="position: absolute; top: 5px; right: 5px;">
          ${_link ? '<button class="btn btn-sm btn-outline-secondary shareLink_grid" style="padding: 0px 3px 0px 3px;"><i class="fa-solid fa-link" style="font-size: 0.7rem; padding: 0px;"></i></button>' : ''}
        </span>
        <div class="card-body">
          <p class="card-text ${_loc ? 'popover-hover' : ''}" ${popoverContent} style="font-size: 0.8rem;">${_name}</p>
          <p class="card-text text-body-secondary" style="font-size: 0.7rem;">${convertBytesToReadableUnit(_size)}</p>
        </div>
      </div>`;
    });

    const gridContent = document.getElementById('grid_content');
    gridContent.innerHTML = htmlArray.join('');

    // ⏳ 2. 비동기적으로 썸네일 가져와서 개별 업데이트
    view_contents.forEach(async ({ _type, _name, _loc, _thumbnail }) => {
      if (_thumbnail === 'image' || _thumbnail === 'video') {
        const thumbnailTag = await generateThumbnailOrIconTag(_type, `${_loc && _type !== 'Directory' ? _loc + '/' + _name : current_path + '/' + _name}`, _thumbnail, 148, true);

        // 해당 카드의 썸네일 업데이트
        const card = document.querySelector(`.card[data-name="${_name}"] .thumbnail-container`);
        if (card) card.innerHTML = thumbnailTag;
      }
    });

    document.querySelectorAll('#grid_content p.popover-hover').forEach(td => {
      let popover = new bootstrap.Popover(td, {
        trigger: "manual",
        placement: "bottom",
      });

      let hideTimeout;

      td.addEventListener("mouseenter", () => {
        clearTimeout(hideTimeout);
        popover.show();
      });

      td.addEventListener("mouseleave", () => {
        hideTimeout = setTimeout(() => {
          popover.hide();
        }, 100); // 팝오버가 사라지기 전 100ms 지연
      });

      td.addEventListener("click", () => {
        popover.hide(); // 팝오버를 수동으로 숨기기
      });
    });

    const dir_divs = document.querySelectorAll('#grid_content div.directory');
    dir_divs.forEach(dir_div => {
      dir_div.addEventListener('click', async (e) => {
        e.stopPropagation();
        allowSubscriptionCall = true;
        const $file_name = dir_div.querySelector('input').getAttribute('value').trim();
        let targetPath = null;
        const loc = e.target.closest('div').parentElement.dataset.loc;
        if (loc == 'undefined') {
          targetPath = `${current_path == '/' ? '' : current_path}/${$file_name}`; 
        } else {
          targetPath = loc || '';
        }
        toc_flag = false;
        await fetchDirectoryDetails(targetPath);
        toc_flag = true;
      });
    });  

    const file_divs = document.querySelectorAll('#grid_content div.file');
    file_divs.forEach(file_div => {
      file_div.addEventListener('dblclick', async (e) => {
        e.stopPropagation();
        let currentPath = null;
        const loc = e.target.closest('div').parentElement.dataset.loc;
        currentPath = current_path.startsWith('/') ? current_path.slice(1) : current_path;
        currentPath = loc === 'undefined' ? current_path : `${loc.endsWith('/') ? loc.substring(0, loc.length - 1) : loc}`;
        
        // const currentPath = current_path.startsWith('/') ? current_path.slice(1) : current_path;
        const file_name = file_div.querySelector('input').getAttribute('value');
        const file_ext = file_name.includes('.') ? file_name.split('.')[1] : undefined;
        const image_exts = ['png', 'jpeg', 'jpg', 'gif', 'bmp', 'tiff', 'webp'];
        const video_exts = ['mp4', 'avi', 'mov', 'mkv', 'wmv', 'flv'];
        const audio_exts = ['mp3', 'aac', 'm4a', 'ogg', 'wav', 'flac', 'webm'];
        const code_exts = ['html', 'css', 'js', 'py'];
        const office_exts = ['hwp', 'hwpx', 'pdf'];
        if (video_exts.includes(file_ext)) {
          openFile(`${currentPath}/${file_name}`, true, false);
        } else if (audio_exts.includes(file_ext)) {
          openFile(`${currentPath}/${file_name}`, false, true);  // 비디오 파일
        } else if (image_exts.includes(file_ext) || code_exts.includes(file_ext) || office_exts.includes(file_ext)) {
          openFile(`${currentPath}/${file_name}`);
        } 
      });
    });  

    const $inputs = gridContent.querySelectorAll('input');
    $inputs.forEach(input => {
      if (input.checked) {
        input.closest('span').classList.remove('hidden');
        input.closest('.card').classList.add('border-primary');
      }
    });

    // 이벤트 위임 방식으로 카드의 호버 이벤트 처리
    gridContent.addEventListener('mouseover', (event) => {
      const card = event.target.closest('.card');
      if (card) {
        card.classList.add('border-primary'); // 카드 테두리 강조
        const span = card.querySelector('span');
        const checkbox = span?.querySelector('input');
        if (span) {
          span.classList.remove('hidden'); // 체크박스 보이기
        }
      }
    });

    gridContent.addEventListener('mouseout', (event) => {
      const card = event.target.closest('.card');
      if (card) {
        const span = card.querySelector('span');
        const checkbox = span?.querySelector('input');
        if (span && !checkbox?.checked) {
          span.classList.add('hidden'); // 체크박스 숨기기
          card.classList.remove('border-primary'); // 카드 테두리 원래대로
        }
      }
    });

    // 각 체크박스에 이벤트 리스너 추가
    const checkboxes = document.querySelectorAll('#grid_content .form-check-input');
    checkboxes.forEach(checkbox => {
      checkbox.addEventListener('click', (event) => {
        event.stopPropagation();
      });
      checkbox.addEventListener('change', (event) => {
        const itemValue = checkbox.getAttribute('value'); // checkbox 자체에서 속성을 가져옴
        const loc = event.target.closest('div').dataset.loc;

        let targetFullPath = null;
        if (loc === 'undefined') {
          targetFullPath = (current_path === '/' ? '' : current_path) + '/' + itemValue;
          // targetFullPath = current_path + '/' + itemValue;
        } else if (loc.endsWith('/')) {
          targetFullPath = loc.slice(1) + itemValue;
        } else {
          targetFullPath = loc.slice(1);
        }

        targetFullPath = targetFullPath.startsWith('/') ? targetFullPath : '/' + targetFullPath;

        if (event.target.checked) { // 체크 상태인 경우에만 실행
          document.getElementById('rp_title').textContent = itemValue;
          fetchItemThumbnailAndDetails(targetFullPath);
          store.dispatch({ type: "ADD_SELECTED_ITEM", payload: targetFullPath });
        } else { // 체크 해제된 경우
          store.dispatch({ type: "REMOVE_SELECTED_ITEM", payload: targetFullPath });
        }
      });
    });

    document.querySelectorAll('button.shareLink_grid').forEach(link => {
      link.addEventListener('click', (e) => {
        event.stopPropagation();
        const { current_path } = store.getState();
        $('#shared_dir_link').text(current_path + '/' + event.target.closest('div').querySelector('p.card-text').textContent.trim());
        $('#createLinkBtnForModal').click();
      });
    });

    reloadingFlag_for_grid = false;
  }

  async function generateBreadcrumbFromPath() {
    const { current_path, directoryTree } = store.getState();
    const $breadcrumb = document.getElementById('breadcrumb');
    const splited_path = current_path.split("{{ base_path }}")[1].split('/').filter(path => path);
 
    const html_for_crumb = splited_path.map((_, index) => {
      const path = "{{ base_path }}" + '/' + splited_path.slice(0, index + 1).join('/');
      const dir_name = splited_path[index];
      const isActive = index === splited_path.length - 1;
      
      return `
        <li data-path="${path}" class="breadcrumb-item ${isActive ? 'active fw-semibold' : 'fw-light mobile'}" ${isActive ? 'aria-current="page"' : ''}>${dir_name}</li>
      `;
    }).join('');

    $breadcrumb.innerHTML = '<li data-path="{{ base_path }}" id="home" class="breadcrumb-item fw-light" >Home</li>' + html_for_crumb;

    const $breadcrumbs = document.querySelectorAll('#breadcrumb li');
    $breadcrumbs.forEach(li => {
      li.addEventListener('click', async (e) => {
        e.stopPropagation();
        if (!li.dataset.path.includes("{{ base_path }}")) {
          alert('잘못된 접근입니다.');
          return
        }
        await fetchDirectoryDetails(li.dataset.path);
      });
    });
  }

  const sortByRule = (rule, oddEven) => (a, b) => {
    const num = oddEven == 'odd' ? -1 : 1;
    if (a[rule] === b[rule]) {
      return 0;
    } 
    return a[rule] > b[rule] ? 1 * num : -1 * num;
  }

  function reducer(state, action) {
    if (state === undefined) {
      return {
        directoryTree: [],
        view_contents: [],
        current_path: document.getElementById('basePath')?.textContent,
        selectedItems: [], // 선택된 항목들
        checkedFilePathsForMove: [],
        checkedFilePathsForCopy: [],
      }
    }
    let newState;
    if (action.type === 'UPDATE'){
      if (action.target === 'nav_dir') {
        const newContents = [...action.content];
        newState = Object.assign({}, state, {
          directoryTree: newContents,
        });
      } else if (action.target === 'file_list') {
        const newContents = [...action.content].sort(sortByRule('_name', 'even'));
        newState = Object.assign({}, state, {
          view_contents: newContents,
          current_path: action.dir,
          selectedItems: [],
        });
      } else if (action.target === 'breadcrumb') {
        const pathLen = state.current_path.split('/');
        if (pathLen.length > 0) {
          const updatedPath = pathLen.slice(0, pathLen.length - 1).join('/');
          newState = Object.assign({}, state, {
            current_path: updatedPath,
            selectedItems: [],
          });
        }
      } else if (action.target === 'sort_table') {
        let key = null;
        switch (action.rule) {
          case 'type':
            key = '_type';
            break;
          case 'size':
            key = '_size';
            break;
          case 'name':
            key = '_name';
            break;
          case 'date':
            key = '_modified'
            break;
          default:
            return;
        }
        const newContents = [...state.view_contents].sort(sortByRule(key, action.count));
        newState = Object.assign({}, state, {
          view_contents: newContents,
        });
        reloadingFlag_for_article = true;
        reloadingFlag_for_grid = true;           
      }
    } else if (action.type === 'ADD_SELECTED_ITEM') {
      newState = {
        ...state,
        selectedItems: [...state.selectedItems, action.payload],
      };
    } else if (action.type === 'REMOVE_SELECTED_ITEM') {
      newState ={
        ...state,
        selectedItems: state.selectedItems.filter(
          (item) => item != action.payload
        ),
      };
    } else if (action.type === 'ADD_SELECTED_ITEMS') {
      newState = {
        ...state,
        selectedItems: [...state.selectedItems, ...action.payload],
      };
    } else if (action.type === 'REMOVE_SELECTED_ITEMS') {
      newState ={
        ...state,
        selectedItems: [...state.selectedItems].filter(
          (item) => ![...action.payload].includes(item)
        ),
      };
    } else if (action.type === 'DELETE_SELECTED_ITEMS') {
      newState = {
        ...state,
        view_contents: [...state.view_contents].filter(
          (item) => !(action.payload || []).includes(item['_name']) // undefined 방지
        ),
        directoryTree: [...state.directoryTree].filter(
          (item) => !(action.dir || []).includes(item['id'])
        ),
      };
    } else if (action.type === 'RENEW_TRANSFER_ITEMS') {
      newState = {
        ...state,
        checkedFilePathsForMove: action.payload,
        checkedFilePathsForCopy: [],
      }
    } else if (action.type === 'RENEW_COPY_ITEMS') {
      newState = {
        ...state,
        checkedFilePathsForMove: [],
        checkedFilePathsForCopy: action.payload,
      }
    } else if (action.type === 'COMPLETE_TRANSFER_ITEMS') {
      newState = {
        ...state,
        checkedFilePathsForMove: [],
        checkedFilePathsForCopy: [],
      }
    }
    return newState;
  }

  const productionURL = 'http://121.189.157.152:8080';
  const testURL = 'http://127.0.0.1:8080';
  const localURL = 'http://172.30.1.25:8080';
  let _URL = null;
  if (window.location.href.split('/')[2] === '127.0.0.1:8080'){
    _URL = testURL;
  } else if (window.location.href.split('/')[2] === '172.30.1.25:8080'){
    _URL = localURL;
  } else {
    _URL = productionURL;
  }

  const fetchDirectoryContents = async () => {
    const state = store.getState();
    const url = `${_URL}/cloudstorage/directoryContents/`;
    
    try {
      const response = await fetch(url, { method: 'GET' });
      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      if (response.status === 204) {
        console.log('No Content');
        return;
      }

      const res = await response.json();
      const directoryTree = res.message.map((item, idx) => {
        const isFile = item.includes('.');
        const num = item.split('/').length - 1; 
        const _path = item.split('/').pop();
        return {
          id: idx + 1,
          path: item,
          pathForDisplay: _path,
          subdirectoryDepth: num,
          type: isFile ? 'file' : 'directory',
          children: [],
        };
      });

      directoryTree.forEach((elem) => {
        const children = directoryTree.filter(item => 
          item.path.startsWith(`${elem.path}/`) && item.path !== elem.path
          && !item.path.split(`${elem.path}/`)[1].includes('/')
        );
        const children_ids = children.map(child => child.id);
        elem.children = children_ids;
      });

      store.dispatch({ type: 'UPDATE', target: 'nav_dir', content: directoryTree });
    } catch (error) {
      console.error('Error:', error);
    }
  };

  const fetchDirectoryDetails = async (dir_path) => {
    const $target = document.getElementById('my_table').classList.contains('invisible') ? document.getElementById('my_grid') : document.getElementById('my_table');
    $target.classList.toggle('invisible', true);
    document.getElementById('placeholder').classList.toggle('d-flex', true);
    document.getElementById('placeholder').classList.toggle('invisible', false);
    
    const state = store.getState();
    const dir_to_pass = dir_path.startsWith('/') ? dir_path.slice(1) : dir_path;
    const url = `${_URL}/cloudstorage/listDirectoryDetails/${dir_to_pass}`;
    
    try {
      const response = await fetch(url, { method: 'GET' });
      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      if (response.status === 204) {
        console.log('No Content');
        return;
      }

      const res = await response.json();
      document.getElementById('placeholder').classList.toggle('invisible', true);
      document.getElementById('placeholder').classList.toggle('d-flex', false);
      $target.classList.toggle('invisible', false);
      reloadingFlag_for_article = true;
      reloadingFlag_for_grid = true;
      store.dispatch({ type: 'UPDATE', target: 'file_list', content: res.message, dir: dir_path });
      initializeTableHeader();
      document.getElementById('rp_title').textContent = dir_path;
      await fetchItemThumbnailAndDetails(dir_path);
    } catch (error) {
      console.error('Error:', error);
    }
  };

  const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
  window.store = store;
  // store.subscribe(TOC);
  store.subscribe(article);
  store.subscribe(grid_article);
  store.subscribe(updateButtonIconBasedOnCheckboxes);
  store.subscribe(generateBreadcrumbFromPath);

  window.onload = async function(){
    fetchDirectoryDetails(document.getElementById('basePath')?.textContent);
    await fetchDirectoryContents();
    
    const rightPanel = document.getElementById('right_panel');
    document.getElementById('infoToggleBtn').addEventListener('click', () => {
      rightPanel.classList.toggle('hidden'); // .hidden 클래스 추가
    });
    
    const $my_table = document.getElementById('my_table');
    const $my_grid = document.getElementById('my_grid');
    const $tableBtn = document.getElementById('tableBtn');
    const $gridBtn = document.getElementById('gridBtn');

    // 버튼 및 콘텐츠 전환 함수
    function toggleMode(activeBtn, inactiveBtn, showElement, hideElement) {
      activeBtn.classList.add('currentMode');
      inactiveBtn.classList.remove('currentMode');
      showElement.classList.remove('invisible');
      hideElement.classList.add('invisible');
    }

    // 이벤트 리스너 설정
    $tableBtn.addEventListener('click', () => {
      if (!$tableBtn.classList.contains('currentMode')) {
        toggleMode($tableBtn, $gridBtn, $my_table, $my_grid);
      }
    });

    $gridBtn.addEventListener('click', () => {
      if (!$gridBtn.classList.contains('currentMode')) {
        toggleMode($gridBtn, $tableBtn, $my_grid, $my_table);
      }
    });

    document.getElementById('toggleAllCheckboxId').addEventListener('click', (e) => {
      const { selectedItems, view_contents, current_path } = store.getState();
      const $checkboxes = document.querySelectorAll('#my_table td input');
      let itemName = [];
      $checkboxes.forEach(checkbox => {
        itemName.push(checkbox.dataset.loc === 'undefined' ? `${current_path === '/' ? '' : current_path}/${checkbox.value}` : checkbox.dataset.type === 'directory' ? checkbox.dataset.loc : `${checkbox.dataset.loc}${checkbox.value}`);
      });
      if (selectedItems.length == 0) { // 모든 요소 선택 후, 체크박스 아이콘으로 변경
        store.dispatch({ type: "ADD_SELECTED_ITEMS", payload: itemName });
      } else { // 모든 요소 해제 후, 빈 상자 아이콘으로 변경
        store.dispatch({ type: "REMOVE_SELECTED_ITEMS", payload: itemName });
      }
    });
    
    document.getElementById('downloadBtn').addEventListener('click', async () => {
      const state = store.getState();
      const { selectedItems, current_path } = state;
      const progressBar = document.getElementById('downloadProgress'); // 진행률 바
      const progressBar2 = document.getElementById('downloadProgress2');
      const progressDiv = document.getElementById('progressDiv');
      progressDiv.classList.remove('invisible');
      const $p = progressDiv.querySelector('p');

      let idx = 0;
      let progress2 = 0; 
      const num_of_items = selectedItems.length;

      try {
        for (const file_name of selectedItems) {
          idx += 1;
          const file_path = file_name;
          $p.textContent = file_name.split('/').pop();
          
          const url = `${_URL}/cloudstorage/sendFileResponse/${file_path}`;
          
          // fetch 요청 (HEADERS 포함)
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

          // 파일 크기 가져오기
          const contentLength = response.headers.get('Content-Length');
          if (!contentLength) throw new Error("Cannot determine file size.");
          const totalSize = parseInt(contentLength, 10);

          // 스트리밍 다운로드 설정
          const reader = response.body.getReader();
          let receivedSize = 0; // 받은 데이터 크기
          let chunks = []; // 청크 저장

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            chunks.push(value);
            receivedSize += value.length;

            // 진행률 계산 및 표시
            const progress = Math.round((receivedSize / totalSize) * 100); 
            progressBar.style.width = progress + "%";
            progressBar.innerText = progress + "%";
            
          }
          progress2 = Math.round((idx / num_of_items) * 100);
          progressBar2.style.width = progress2 + "%";
          progressBar2.innerText = progress2 + "%";

          // Blob 생성 및 다운로드 실행
          const blob = new Blob(chunks);
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = file_name.split('/').pop();
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        }

        // 다운로드 완료 후 진행률 초기화
        progressBar.style.width = "0%";
        progressBar.innerText = "0%";
        progressBar2.style.width = "0%";
        progressBar2.innerText = "0%";
        $p.textContent = '';
        progressDiv.classList.add('invisible');

        $('#toggleAllCheckboxId').click();
      } catch (error) {
        console.error('Error: ', error);
      }
    });

    // 📂 폴더 선택 시 이벤트
    document.getElementById('inputFolder').addEventListener('change', async function (event) {
      const fileList = Array.from(event.target.files).map(file => ({
        file,
        relativePath: file.webkitRelativePath
      }));
      await handleFileUpload(fileList, _URL + '/cloudstorage/saveUploadedFolderFromChunks/', true);
      this.value = '';
    });

    // 📄 파일 선택 시 이벤트
    document.getElementById('inputFiles').addEventListener('change', async function (event) {
      const fileList = Array.from(event.target.files).map(file => ({ file })); // 파일도 동일한 구조로 맞춤
      await handleFileUpload(fileList, _URL + '/cloudstorage/saveUploadedFileFromChunks/');
      this.value = '';
    });

    document.getElementById('file_list').addEventListener("dragover", (event) => {
      event.preventDefault();
      event.currentTarget.style.border = "5px solid red";
    });

    document.getElementById('file_list').addEventListener("dragleave", (event) => {
      event.currentTarget.style.border = "";
    });

    document.getElementById('file_list').addEventListener("drop", async function (event) {
      event.preventDefault();
      this.style.border = "";

      let items = event.dataTransfer.items;
      let files = event.dataTransfer.files; // 추가
      if (!items) return;

      let fileList = [];
      for (const item of items) {
        const entry = item.webkitGetAsEntry();
        if (entry) await getAllFilesFromDirectory(entry, fileList);
      }

      // 🔥 단순 파일 드래그&드롭 처리 추가
      if (files.length > 0) {
        for (const file of files) {
          if (!fileList.some(f => f.file.name === file.name)) { // 중복 방지
            fileList.push({ file, relativePath: file.name });
          }
        }
      }

      if (fileList.length === 0) {
        alert("업로드할 파일이 없습니다.");
        return;
      }

      await handleFileUpload(fileList, _URL + '/cloudstorage/saveUploadedFolderFromChunks/', true);
    });

    async function handleFileUpload(files, uploadUrl, isFolder = false) {
      if (!files || files.length === 0) {
        alert("업로드할 파일이 없습니다.");
        return;
      }

      const { current_path, directoryTree } = store.getState();
      const chunkSize = 1 * 1024 * 1024;
      const currentPath = current_path.startsWith('/') ? current_path.slice(1) : current_path;
      const progressBar = document.getElementById('downloadProgress');
      const progressBar2 = document.getElementById('downloadProgress2');
      const progressDiv = document.getElementById('progressDiv');
      const $p = progressDiv.querySelector('p');

      progressDiv.classList.remove('invisible');

      let idx = 0;
      const num_of_items = files.length;

      for (const fileObj of files) {
        if (!fileObj || !fileObj.file) {
          console.warn("⚠ 잘못된 파일 객체 발견, 건너뜁니다.", fileObj);
          continue;
        }

        const file = fileObj.file;
        const filePath = isFolder ? fileObj.relativePath : currentPath;
        idx += 1;

        const totalChunks = Math.ceil(file.size / chunkSize);
        $p.textContent = file.name;

        for (let chunkIndex = 0; chunkIndex < totalChunks; chunkIndex++) {
          const start = chunkIndex * chunkSize;
          const end = Math.min(start + chunkSize, file.size);
          const chunk = file.slice(start, end);

          const formData = new FormData();
          formData.append('file', chunk);
          formData.append('fileName', file.name);
          formData.append('filePath', filePath);
          formData.append('chunkIndex', chunkIndex);
          formData.append('totalChunks', totalChunks);
          formData.append('currentPath', currentPath);

          try {
            const response = await fetch(uploadUrl, {
              method: 'POST',
              body: formData
            });

            const res = await response.json();
            // console.log(`Chunk ${chunkIndex + 1}/${totalChunks} uploaded:`, res.message);

            const progress = Math.round((chunkIndex / totalChunks) * 100);
            progressBar.style.width = progress + "%";
            progressBar.innerText = progress + "%";
          } catch (error) {
            console.error("❌ 파일 업로드 중 오류 발생:", error);
          }
        }

        progressBar.style.width = "0%";
        progressBar.innerText = "0%";
        progressBar2.style.width = Math.round((idx / num_of_items) * 100) + "%";
        progressBar2.innerText = Math.round((idx / num_of_items) * 100) + "%";
        $p.textContent = '';
      }

      progressDiv.classList.add('invisible');
      updateUI(current_path, directoryTree);
    }

    async function updateUI(current_path, directoryTree, target_dir=undefined) {
      await fetchDirectoryDetails(current_path);
      await fetchDirectoryContents();
    }

    async function getAllFilesFromDirectory(entry, fileList, path = "") {
      return new Promise((resolve, reject) => {
        if (entry.isFile) {
          entry.file(file => {
            fileList.push({ file, relativePath: path + file.name });
            resolve();
          }, reject);
        } else if (entry.isDirectory) {
          const reader = entry.createReader();
          reader.readEntries(async entries => {
            if (!entries.length) return resolve();
            await Promise.all(entries.map(subEntry => getAllFilesFromDirectory(subEntry, fileList, path + entry.name + "/")));
            resolve();
          }, reject);
        }
      });
    }
  }
</script>
{% endblock %}