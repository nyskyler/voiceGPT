{% extends "base2.html" %}
{% block content %}
<style>
  #myRow {
    display: flex;
    flex-direction: row;
  }
  #sidebar {
    display: flex;
    flex-direction: column;
    flex: auto;
    height: 94vh;
    border-right: 1px solid #DDDDDD;
    transform: translateX(0); /* 기본 위치 */
    transition: transform 0.5s ease, width 0.5s ease; /* 슬라이드 애니메이션 */
    padding: 0px; 
    margin: 0 auto;
  }
  #nav_dir {
    flex: auto;
    padding: 1rem;
    overflow-y: auto;
    background-color: #F6F7FA;
  }
  #toc {
    white-space: nowrap; /* 줄 바꿈 방지 */
    overflow-x: auto;    /* 가로 스크롤 표시 */
    display: block;      /* ul 기본 블록 요소로 설정 */
  }
  #toc li {
    display: inline-block; /* 목록 항목을 인라인 블록으로 설정하여 한 줄에 표시 */
  }
  #nav_dir .list-group-item {
    border: none;
    background-color: #F6F7FA;
  }
  #storage_info {
    padding: 0.6rem 1rem 1rem 1rem;
    border-top: 1px solid #DDDDDD;
    background-color: #F6F7FA;
    /* 기본 높이만 차지 */
    /* flex-shrink: 0; */
  }
  #storage_info span {
    font-size: 0.8rem;
  }
  #nav_files {
    display: flex;
    flex-direction: column;
    flex: auto;
    height: 94vh;
    transition: flex 0.5s ease; /* 슬라이드 애니메이션 */
  }
  .sidebar-hidden {
    transform: translateX(-100%);
    transition: transform 0.5s ease, width 0.5s ease;
    width: 0%;
    padding: 0px;
  }
  .nav_files_expanded {
    flex-grow: 1; /* 부모 너비를 기준으로 남은 공간 채우기 */
    transition: flex-grow 0.5s ease;
  }
  .btn-file, .btn-folder {
    margin-left: 0.2rem; 
    padding: 0.2rem 0.6rem 0.3rem 0.6rem;
    background-color: #F1F3F9; 
  }
  .btn-file:hover, .btn-folder:hover {
    background-color: #D1D1D1; 
  }
  button span {
    font-size: 0.8rem; 
    font-weight: bold; 
  }
  #file_list {
    display: flex;
    flex-direction: row;
    flex: auto;
    overflow-y: auto;
    padding: 1rem;
  }
  #placeholder {
    flex: auto;
  }
  #my_table {
    flex: auto;
    min-width: 600px;
    overflow-y: auto;
    padding-left: 0.3rem;
    padding-right: 0.3rem;
  }
  #my_table.invisible {
    display: none;
  }
  #my_grid {
    flex: auto;
    min-width: 600px;
    overflow-y: auto;
  }
  #my_grid.invisible {
    display: none;
  }
  #right_panel {
    display: flex;
    flex-direction: column;
    width: 350px;
    min-width: 300px;
    height: 100%;
    border-left: 1px solid #DDDDDD;
    padding: 1rem; 
  }
  #right_panel.hidden {
    /* width: 0%; */
    display: none;
  }
  .invisible {
    display: none;
  }
  .currentMode {
    color: #4078FF !important; 
  }
  #toggleAllCheckboxId {
    font-size: 1.2rem;
  }
  .table-hover td, .table-hover th {
    white-space: nowrap;
  }
  .flex-grow {
    width: 100%;
    white-space: normal;
  }
  .table thead th {
    position: sticky;
    top: 0; /* 테이블 헤더가 스크롤될 때 고정 위치 */
    background-color: white; /* 헤더 배경색 설정 */
    z-index: 1; /* 다른 콘텐츠보다 위에 표시되도록 설정 */
    font-weight: normal;
    font-size: 0.7rem;
    color: #767780;
  }
  .table tr .mobile {
    color: #9398A0;
    font-size: 0.8rem;
    font-weight: normal;
  }
  tbody#rp_text_info tr td {
    border: none !important;
  }
  span#rp_title {
    word-break: break-word;  /* 긴 단어를 적절히 줄바꿈 */
    white-space: normal;
  }
  td.td_key {
    color: #767780;
    white-space: nowrap;
    font-weight: normal;
    font-size: 0.8rem;
  }
  td.td_value {
    color: black;
    font-weight: normal;
    font-size: 0.8rem;
    word-break: break-word;  /* 긴 단어를 적절히 줄바꿈 */
    white-space: normal;
  }
  #table_body td.file,
  #table_body td.directory {
    word-break: break-word;  /* 긴 단어를 적절히 줄바꿈 */
    white-space: normal;    /* 텍스트가 줄 바꿈을 허용 */
  }
  #grid_content {
    display: flex;         /* Flexbox 레이아웃 사용 */
    flex-flow: row wrap;    /* 줄바꿈 허용 */
    justify-content: flex-start;
    padding: 3rem;
    gap: 1rem;             /* 요소 간격 설정 */
  }
  #grid_content i {
    font-size: 4.5rem;
    padding: 2.5rem;
  }
  #grid_content p {
    white-space: nowrap;
    overflow: hidden; 
    text-overflow: ellipsis;
    margin: 0;
  }
  #grid_content .card-body {
    padding: 0px;
  }
  #grid_content .card span.hidden {
    display: none;
  }
  .form-check-input:focus {
    box-shadow: none;
  }
  #home {
    margin-left: 1rem;
  }
  #breadcrumb li {
    cursor: pointer;
  }
  #banner {
    flex: 0 0 auto;
    /* padding-top: 0.9rem;
    padding-bottom: 0.5rem; */
    border-bottom: 1px solid #DDDDDD;
  }
  #top_banner {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    padding-top: 0.6rem;
  }
  .header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    width: 100%;
    /* padding: 0 10px; */
  }
  .cursor-pointer {
    cursor: pointer; /* 포인터 모양으로 변경 */
  }
  #toggleButton {
    display: none;
  }
  /* Toggle Button */
  .toggle-btn {
    border: none;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    outline: none;
    margin-right: 0.3rem;
  }
  .toggle-btn i {
    font-size: 1.2rem;
  }
  .btn-margin {
    margin-left: 0.8rem;
  }
  #searchInput:focus, #searchInput2:focus, #topicInput:focus {
    outline: none;
    box-shadow: none;
    border-color: black;
  }
  .btn-transparent {
    background-color: transparent;
    border: none;
  }
  .btn-transparent:hover {
    background-color: rgba(0, 0, 0, 0.1); /* 호버 시 배경색 추가 (선택 사항) */
  }

  @media (min-width: 1024px) and (max-width: 1366px) {
  /* 아이패드 프로 12.9인치 화면에만 적용할 스타일 */
    #sidebar {
      height: 87vh;
    }
    #nav_dir {
      height: 79vh;
    }
    #nav_files {
      height: 87vh;
    }
  } 

  @media (max-width: 767.98px) and (orientation: portrait) {
    #nav_files {
      height:79vh; /* 모바일에서는 전체 화면 높이로 설정 */
    }
    .toggle-btn {
      display: none;
    }
    #fontIncrease, #fontDecrease {
      display: none;
    }
    #sidebar {
      display: none;
    }
    .mobile {
      display: none;
    }
    #my_table {
      min-width: 300px;
    }
    #my_grid {
      min-width: 300px;
    }
    #right_panel, #infoToggleBtn {
      display: none;
    }
    form#searchForm {
      display: none !important;
    }
    #toggleButton {
      display: inline-block;
    }
    #home {
      margin-left: 0rem;
    }
    #grid_content {
     padding: 1.8rem;
  }
  }
</style>
<div class="container-fluid">
  <div id="myRow" class="row">
    <div id="sidebar" class="col-12 col-md-3 col-xl-2">
      <div id="nav_dir">
        <ul id="toc" class="list-group list-group-flush"></ul>
      </div>
      <div id="storage_info">
        <div style="margin-bottom: 0.5rem;">
          <span style="margin-right: 0.3rem;"><i class="fa-regular fa-hard-drive"></i></span>
          <span id="used" style="font-weight: bold; color: #4078FF;"></span>
          <span> / </span>
          <span id="total"></span>
        </div>
        <div class="progress" role="progressbar" aria-label="Basic example" aria-valuenow="50" aria-valuemin="0" aria-valuemax="100">
          <div id="storage_bar" class="progress-bar"></div>
        </div>
        <!-- 📌 다운로드 진행률 바 -->
        <div style="width: 100%; background: #ddd; border-radius: 5px; margin-top: 10px;">
          <div id="downloadProgress" style="
            width: 0%;
            height: 25px;
            background: #4CAF50;
            text-align: center;
            line-height: 25px;
            color: white;
            border-radius: 5px;">
            0%
          </div>
        </div>
      </div>
    </div>
    <div id="nav_files" class="col-12 col-md-9 col-xl-10 p-0">
      <div id="top_banner" style="display: flex; align-items: center;">
        <div style="display: inline-block;">
          <span>
            <button id="toggleButton" class="toggle-btn btn btn-transparent">
              <!-- <i class="fa-regular fa-square-caret-left"></i>FontAwesome icon -->
              <i class="fa-solid fa-chevron-left"></i>
            </button>
          </span>
          <nav class="fs-5" style="--bs-breadcrumb-divider: url(&#34;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8'%3E%3Cpath d='M2.5 0L1 1.5 3.5 4 1 6.5 2.5 8l4-4-4-4z' fill='%236c757d'/%3E%3C/svg%3E&#34;); display: inline-block;" aria-label="breadcrumb">
            <ol id="breadcrumb" class="breadcrumb">
            </ol>
          </nav>
        </div>
        <form id="searchForm" style="display: flex; align-items: center;">
          <div class="input-group" style="display: flex; align-items: center; border: none; outline: none;">
            <input type="text" style="border: 1px solid black; border-right: 0; border-radius: 4px 0 0 4px;" maxlength="12" id="searchInput" name="serachInput" class="form-control" aria-label="Message" aria-describedby="send-button" autocomplete="off" rows="1">
            <button id="searchBtn" class="btn btn-light" style="margin-left: 0; border: 1px solid black; border-left: 0; border-radius: 0 4px 4px 0;" type="submit">
              <i class="fa-solid fa-magnifying-glass"></i>
            </button>
          </div>
        </form>
      </div>
      <div id="banner">
        <div class="header">
          <span>
            <button id="toggleAllCheckboxId" class="btn btn-transparent"><i class="fa-regular fa-square" style="color: #DEE2E6;"></i></button>
            <button id="uploadBtn" class="btn btn-transparent" style="background-color: #4078FF; padding: 0.2rem 0.6rem 0.3rem 0.6rem;"><i class="fa-solid fa-arrow-up-from-bracket" style="font-size: 0.9rem;  color: white;"></i><span style="color: white;"> 올리기</span></button>
            <!-- 새 폴더의 이름을 입력받는 모달창 -->
            <button type="button" id="newfolderBtn" class="btn btn-folder" data-bs-toggle="modal" data-bs-target="#createFolderModal" data-bs-whatever="{{ g.user.username }}"><span>새 폴더</span></button>
            <div class="modal fade" id="createFolderModal" tabindex="-1" aria-labelledby="createFolderModalLabel">
              <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                  <div class="modal-header">
                    <h1 class="modal-title fs-5" id="createFolderModalLabel"></h1>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                  </div>
                  <div class="modal-body">
                    <form id="createFolderForm">
                      <div class="mb-3">
                        <label for="folder_name" class="col-form-label"></label>
                        <input type="text" class="form-control" id="folder_name" minlength="1" maxlength="30" placeholder="새 폴더" autocomplete="off">
                      </div>
                    </form>
                  </div>
                  <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">취소</button>
                    <button type="submit" class="btn btn-primary" form="createFolderForm">확인</button>
                  </div>
                </div>
              </div>
            </div>
            <span id="btnFiles" class="invisible">
              <button id="downloadBtn" class="btn btn-file"><span>내려받기</span></button>
              <button id="shareBtn" class="btn btn-file"><span>공유</span></button>
              <!-- 삭제 확인 모달창 -->
              <button type="button" id="deleteBtn" class="btn btn-file" data-bs-toggle="modal" data-bs-target="#deleteModal" data-bs-whatever="{{ g.user.username }}"><span>삭제</span></button>
              <div class="modal fade" id="deleteModal" tabindex="-1" aria-labelledby="deleteModalLabel">
                <div class="modal-dialog modal-dialog-centered">
                  <div class="modal-content">
                    <div class="modal-header">
                      <h1 class="modal-title fs-5" id="deleteModalLabel"></h1>
                      <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                      <p>공유 중이거나 즐겨 찾는 파일도 함께 삭제됩니다.</p>
                    </div>
                    <div class="modal-footer">
                      <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">취소</button>
                      <button type="button" id="confirmDeleteBtn" class="btn btn-primary">확인</button>
                    </div>
                  </div>
                </div>
              </div>
              </span>
            </span>
            <span>
            <button id="tableBtn" class="btn btn-transparent currentMode"><i class="fa-solid fa-bars"></i></button>
            <button id="gridBtn" class="btn btn-transparent"><i class="fa-solid fa-grip"></i></button>
            <button id="infoToggleBtn" class="btn btn-transparent"><i class="fa-solid fa-circle-info" style="color: #4078FF;"></i></button>
          </span>
        </div>
      </div>
      <div id="file_list" style="padding: 0px;">
        <div id="placeholder" class="invisible text-center flex-column align-items-center justify-content-start" style="margin-top: 5rem;">
          <div class="spinner-border text-primary mb-3" role="status" style="width: 3rem; height: 3rem;">
            <span class="visually-hidden">Loading...</span>
          </div>
          <p class="placeholder-glow fs-5 mb-3">
            <span class="placeholder col-8"></span>
          </p>
          <div class="d-flex gap-3">
            <div class="placeholder-glow">
              <div class="placeholder rounded bg-warning" style="width: 80px; height: 80px;"></div>
            </div>
            <div class="placeholder-glow">
              <div class="placeholder rounded bg-primary" style="width: 80px; height: 80px;"></div>
            </div>
            <div class="placeholder-glow">
              <div class="placeholder rounded bg-secondary" style="width: 80px; height: 80px;"></div>
            </div>
          </div>
          <p class="mt-4 text-muted">데이터를 불러오는 중입니다... 잠시만 기다려 주세요.</p>
        </div>
        <div id="my_table">
          <table class="table table-hover">
            <thead>
              <tr id="table_header">
              </tr>
            </thead>
            <tbody id="table_body">
            </tbody>
          </table>
        </div>
        <div id="my_grid" class="invisible">
          <div id="grid_content">
          </div> 
        </div>
        <div id="right_panel">
          <div id="rp_header" class="fs-5">
            <span id="rp_title" class="fw-semibold"></span>
          </div>
          <div id="rp_thumb"></div>
          <table class="table">
            <tbody id="rp_text_info">
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>
{% endblock %}
{% block script %}
<script type="module">
  import { createStore } from 'https://cdnjs.cloudflare.com/ajax/libs/redux/5.0.1/redux.legacy-esm.js';

  let toc_flag = true; 

  // 'invisible' 클래스를 토글하는 함수
  function toggleVisibility(item, isInvisible) {
    if (isInvisible) {
      item.classList.add('invisible');
      const icon = item.querySelector('.fa-solid');
      if (icon && icon.classList.contains('fa-folder-open')) {
        icon.classList.remove('fa-folder-open');
        icon.classList.add('fa-folder');
        item.classList.remove('open');
      }
    } else {
      item.classList.remove('invisible');
    }
  }

  // 아이콘을 변경하는 함수
  function toggleFolderIcon(item, isOpen) {
    const icon = item.querySelector('.fa-solid');
    if (icon) {
      if (isOpen) {
        icon.classList.remove('fa-folder');
        icon.classList.add('fa-folder-open');
      } else {
        icon.classList.remove('fa-folder-open');
        icon.classList.add('fa-folder');
      }
    }
  }

  // 하위 아이템을 숨기거나 표시하는 함수
  function handleSubItems(item, shouldDisplay) {
    const targetIds = JSON.parse(item.dataset.subids);
    targetIds.forEach(id => {
      const subItem = document.querySelector(`.list-group-item[data-id='${id}']`);
      if (subItem) {
        toggleVisibility(subItem, shouldDisplay);
        // 하위 항목이 토글되었으면, 그 하위 아이템의 subids도 처리
        if (shouldDisplay) {
          handleSubItems(subItem, shouldDisplay);
        }
      }
    });
  }

  // 특정 ID들의 항목을 표시하는 함수
  function displayTagsById(subids) {
    const listItems = document.querySelectorAll('#toc .list-group-item');
    
    listItems.forEach(item => {
      const itemId = parseInt(item.dataset.id, 10);
      
      // 클릭된 ID가 포함된 아이템만 처리
      if (subids.includes(itemId)) {
        const isCurrentlyInvisible = item.classList.contains('invisible');
        const shouldDisplay = !isCurrentlyInvisible;  // 서브 요소가 가려져 있을 경우, shouldDisplay에 false가 담김
        
        toggleVisibility(item, shouldDisplay);
        
        // 하위 항목을 표시하려면, 하위 아이템이 보이도록 처리
        if (shouldDisplay) {
          handleSubItems(item, shouldDisplay);
        }
      }
    });
  }

  function getStyledDirectoryName(d_path, depth, path, array) {
    const flag = [...array].slice(0, -1).includes(path);
    if (flag) {
      return '&emsp;'.repeat(depth) + '<i class="fa-solid fa-folder-open" style="color: #4078FF;"></i>' + '&emsp;' + d_path;
    } else {
      return '&emsp;'.repeat(depth) + '<i class="fa-solid fa-folder" style="color: #4078FF;"></i>' + '&emsp;' + d_path; 
    }
  }

  const icons = {
    'folder': '<i class="fa-solid fa-folder" style="color: #4078FF;"></i>',
    'pdf': '<i class="fa-solid fa-file-pdf" style="color: #DA5A37"></i>',
    'zip': '<i class="fa-solid fa-file-zipper" style="color: #968069"></i>',
    'doc': '<i class="fa-solid fa-file-word" style="color: #457DD8"></i>',
    'docx': '<i class="fa-solid fa-file-word" style="color: #457DD8"></i>',
    'ppt': '<i class="fa-solid fa-file-powerpoint" style="color: #E76C4E"></i>',
    'pptx': '<i class="fa-solid fa-file-powerpoint" style="color: #E76C4E"></i>',
    'xls': '<i class="fa-solid fa-file-excel" style="color: #30A364"></i>',
    'xlsx': '<i class="fa-solid fa-file-excel" style="color: #30A364"></i>',
    'hwp': '<i class="fa-solid fa-file-signature" style="color: #43A6DD"></i>',
    'hwpx': '<i class="fa-solid fa-file-signature" style="color: #43A6DD"></i>',
    'video': '<i class="fa-solid fa-file-video" style="color: #01C75A"></i>',
  }

  let toc_click_flag = true;
  function TOC(array_for_path=[]) {
    const state = store.getState();
    const html_for_toc = state.directoryTree
      .filter(item => item.type === 'directory')
      .map(({ id, path, children, pathForDisplay, subdirectoryDepth }) => `
        <a href='#' data-id="${id}" data-subids="${JSON.stringify(children)}" class="list-group-item ${path.includes('/') && !array_for_path.includes(path) ? 'invisible' : ''}">
          ${getStyledDirectoryName(pathForDisplay, subdirectoryDepth, path, array_for_path)}
        </a>
      `).join('');
    
    const $toc = document.getElementById('toc');
    $toc.innerHTML = html_for_toc;
    if (!toc_click_flag) {
      return;
    }
    $toc.addEventListener('click', function(e) {
      e.preventDefault();
      const elem = e.target.closest('.list-group-item');
      if (elem) {
        const id = elem.dataset.id;
        const dir_path = [...store.getState().directoryTree].filter(item => item.id == id)[0]?.path;
        if (dir_path && toc_flag) {
          fetchDirectoryDetails(dir_path);
        }
        const subIds = JSON.parse(elem.dataset.subids);
        if (subIds.length > 0) {
          if (!elem.classList.contains('open')) {
            toggleFolderIcon(elem, true);
            elem.classList.add('open');
          } else {
            toggleFolderIcon(elem, false);
            elem.classList.remove('open');
          }
          displayTagsById(subIds);
        }
      }
    });
    toc_click_flag = false;
  }

  function getFileExtensionIcon(_ext) {
    // console.log(_ext);
    const ext = _ext.split('.')[1].toLowerCase();
    let tag = icons[ext] || `<i class="fa-regular fa-file"></i>`;
    return tag;
  }

  function convertBytesToReadableUnit(sizeBytes) {
    let size;
    if (sizeBytes < 1_000_000) {  // Less than 1 MB
      size = `${(sizeBytes / 1_024).toFixed(1)} KB`;
    } else {  // 1 MB or more
      size = `${(sizeBytes / 1_048_576).toFixed(1)} MB`;
    }
    return size;
  }

  function initializeTableHeader() {
    const $table_header = document.getElementById('table_header');
    const $ths = $table_header.querySelectorAll('th');
    $ths.forEach(th => {
      th.remove();
    });
    $table_header.innerHTML = `
      <th scope="col">   </th>
      <th scope="col" data-id="type">종류 </th>
      <th scope="col" data-id="name" class="flex-grow">이름 </th>
      <th scope="col" data-id="size" class="mobile">크기 </th>
      <th scope="col" data-id="date" class="mobile">수정한 날짜 </th>
    `;  

    const ths = document.querySelectorAll('#table_header th');
    ths.forEach((th, idx) => {
      if (idx == 0) {
        return;
      }
      th.addEventListener('click', () => {
        const $elem = document.querySelector('th i');
        if ($elem) {
          $elem.remove();
        }
  
        th.classList.toggle('oddEvenToggle');
        // console.log(th);
        const oddEven = th.classList.contains('oddEvenToggle') ? 'odd' : 'even';
        const $iconEl = document.createElement('i');
        $iconEl.classList.add('fa-solid');
        oddEven == 'odd' ? $iconEl.classList.add('fa-arrow-up') : $iconEl.classList.add('fa-arrow-down');
        // console.log(oddEven);
        th.appendChild($iconEl);
        store.dispatch({ type: 'UPDATE', target: 'sort_table', rule: th.dataset.id, count: oddEven });
      });
    });
  }

  const fetchItemThumbnailAndDetails = async (item_path) => {
    // fetch를 사용하여 서버에서 이미지를 가져오고, Blob과 URL.createObjectURL을 사용하여 이미지를 웹 페이지에 표시하기
    const state = store.getState();
    const url = `${_URL}/cloudstorage/getThumbnailAndDetails/${item_path}`;
    
    try {
      const response = await fetch(url, { method: 'GET' });
      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      if (response.status === 204) {
        console.log('No Content');
        return;
      }

      const $thumbnail = document.getElementById('rp_thumb');
      const $rp_text_info = document.getElementById('rp_text_info');
      $thumbnail.innerHTML = '';
      $rp_text_info.innerHTML = '';
      const res = await response.json();
      // console.log(res.info);
      const mediaTypesForThumbnails = ['pdf', 'image', 'video'];

      if (mediaTypesForThumbnails.includes(res.type)) {
        const thumbnailBase64 = res.data;
        const imageUrl = `data:image/png;base64,${thumbnailBase64}`;
        const $imgElement = document.createElement('img');
        $imgElement.src = imageUrl;
        $imgElement.style.width = '100%'; // Adjust based on container
        $imgElement.style.paddingTop = '0.8rem';
        $imgElement.style.paddingBottom = '0.8rem';
        $thumbnail.appendChild($imgElement);
      } else {
        const $divElement = document.createElement('div');
        $divElement.innerHTML = icons[res.type] || '<i class="fa-regular fa-file"></i>';
        $divElement.style.width = '100%'; // Adjust based on container
        $divElement.style.textAlign = 'center'
        $divElement.style.fontSize = '6rem';
        $divElement.style.paddingTop = '0.8rem';
        $divElement.style.paddingBottom = '0.8rem';
        $divElement.style.backgroundColor = '#F5F6F9';
        $thumbnail.appendChild($divElement);
      }
      
      const $fragment = document.createDocumentFragment();

      Object.entries(res.info).forEach(item => {
        const $tr = document.createElement('tr');
        const $td_for_key = document.createElement('td');
        $td_for_key.classList.add('td_key');
        const $td_for_value = document.createElement('td');
        $td_for_value.classList.add('td_value');
        $td_for_key.textContent = item[0];
        $td_for_value.textContent = (item[1] == '/Users/yuseung-u/Desktop/pythonLab/voiceGPT' ? '/' : item[1]);
        if (res.type == 'folder' && item[0] == '위치') {
          document.getElementById('rp_title').textContent = $td_for_value.textContent;
        } 
        $tr.appendChild($td_for_key);
        $tr.appendChild($td_for_value);
        $fragment.appendChild($tr);
      });
      $rp_text_info.appendChild($fragment);
    } catch (error) {
      console.error('Error:', error);
    }
  }

  function generateThumbnailOrIconTag(_type, _thumbnail, _size=25, card=false) {
    if (_type == 'Directory') {
      return '<i class="fa-solid fa-folder" style="color: #4078FF;"></i>';
    } else if (_thumbnail) {
      const thumbnailBase64 = _thumbnail;
      const imageUrl = `data:image/png;base64,${thumbnailBase64}`;
      return `<img src=${imageUrl} style="width:${_size}px; height:${_size}" padding:2px; text-align: center; ${card ? 'class="card-img-top" alt="..."' : ''}></img>`;
    } else {
      return getFileExtensionIcon(_type);
    }
  }

  function toggleElementVisibilityById(tag, hidden) {
    const flag = $(tag).hasClass('invisible');
    if (hidden && !flag) {  // 태그를 숨기고자 할 경우
      $(tag).addClass('invisible');
    } else if (!hidden && flag) { // 태그를 보이고자 할 경우
      $(tag).removeClass('invisible');
    }
  }

  function updateButtonIconBasedOnCheckboxes() { // 다른 체크박스 요소들이 체크되어 있는지 확인하여, 그 결과에 따라 특정 버튼 요소의 아이콘 모양을 바꿔주는 함수
    const state = store.getState();
    const { view_contents, selectedItems } = state;
    const $toggleAllCheckboxId = document.getElementById('toggleAllCheckboxId');
    if (selectedItems.length == 0) {
      $toggleAllCheckboxId.innerHTML = '<i class="fa-regular fa-square" style="color: #DEE2E6;"></i>';
      toggleElementVisibilityById('#btnFiles', true);
      toggleElementVisibilityById('#newfolderBtn', false);
    } else if (selectedItems && (selectedItems.length == view_contents.length)) {
      $toggleAllCheckboxId.innerHTML = '<i class="fa-solid fa-square-check" style="color: #4078FF;"></i>';
      toggleElementVisibilityById('#btnFiles', false);
      toggleElementVisibilityById('#newfolderBtn', true);
    } else {
      $toggleAllCheckboxId.innerHTML = '<i class="fa-solid fa-square-minus" style="color: #4078FF;"></i>';
      toggleElementVisibilityById('#btnFiles', false);
      toggleElementVisibilityById('#newfolderBtn', true);
    }
  }

  function article() {
    const state = store.getState();
    const { current_path, selectedItems } = state;
    let html_for_article = state.view_contents.map(
      ({ _type, _name, _size, _modified, _thumbnail }) => {
        const isChecked = selectedItems.includes(_name); // 선택 여부 확인
        return `<tr>
          <td><input class="form-check-input" type="checkbox" value="${_name}" ${isChecked ? "checked" : ""} aria-label="..."></td>
          <td>${generateThumbnailOrIconTag(_type, _thumbnail, 25, false)}</td>
          <td class="flex-grow ${_type == 'Directory' ? 'directory' : 'file'}">${_name}</td>
          <td class="mobile">${convertBytesToReadableUnit(_size)}</td>
          <td class="mobile">${_modified}</td>
        </tr>`
    }).join('');

    document.getElementById('table_body').innerHTML = html_for_article;
    const dir_tds = document.querySelectorAll('#table_body td.directory');
    dir_tds.forEach(td => {
      td.addEventListener('click', async (e) => {
        e.stopPropagation();
        toc_flag = false;
        await fetchDirectoryDetails(`${current_path}/${td.textContent}`);
        await updateAndActivateDirectoryTreeItem();
        toc_flag = true;
      });
    });

    // 각 체크박스에 이벤트 리스너 추가
    const checkboxes = document.querySelectorAll('#table_body .form-check-input');
    checkboxes.forEach(checkbox => {
      const row = checkbox.closest('tr');
      if (checkbox.checked) {
        row.classList.add('table-active');
      }
      checkbox.addEventListener('change', (event) => {
        if (event.target.checked) { // 체크 상태인 경우에만 실행
          // 체크박스가 속한 행의 세 번째 <td>의 텍스트 가져오기
          row.classList.add('table-active');
          const nameTd = row.querySelector('td:nth-child(3)');
          // console.log(nameTd.textContent);
          document.getElementById('rp_title').textContent = nameTd.textContent;
          fetchItemThumbnailAndDetails(current_path + '/' + nameTd.textContent);
        } else { // 체크 해제된 경우
          row.classList.remove('table-active');
        }

        const itemName = event.target.value;
        if (event.target.checked) {
          store.dispatch({ type: "ADD_SELECTED_ITEM", payload: itemName });
        } else {
          store.dispatch({ type: "REMOVE_SELECTED_ITEM", payload: itemName });
        }
      });
    });
  }

  function grid_article() {
    const state = store.getState();
    const current_path = state.current_path;
    let html_for_article = state.view_contents.map(
      ({ _type, _name, _size, _thumbnail }) => {
        const isChecked = state.selectedItems.includes(_name); // 선택 여부 확인
        return `
        <div class="card mb-5 text-center ${_type == 'Directory' ? 'directory' : 'file'}" style="width: 150px; height: 150px; position: relative;">
          ${generateThumbnailOrIconTag(_type, _thumbnail, 148, true)}
          <span class="hidden" style="position: absolute; top: 5px; left: 5px;">
            <input class="form-check-input" type="checkbox" value="${_name}" ${isChecked ? "checked" : ""} aria-label="..."> 
          </span>
          <div class="card-body">
            <p class="card-text" style="font-size: 0.8rem;">${_name}</p>
            <p class="card-text" style="font-size: 0.7rem;" class="text-body-secondary">${convertBytesToReadableUnit(_size)}</p>
          </div>
        </div>
        `
      }).join('');

    const gridContent = document.getElementById('grid_content');
    gridContent.innerHTML = html_for_article;

    const dir_divs = document.querySelectorAll('#grid_content div.directory');
    dir_divs.forEach(dir_div => {
      dir_div.addEventListener('click', async (e) => {
        e.stopPropagation();
        toc_flag = false;
        const $file_name = dir_div.querySelector('input').getAttribute('value');
        await fetchDirectoryDetails(`${current_path}/${$file_name}`);
        await updateAndActivateDirectoryTreeItem();
        toc_flag = true;
      });
    });  

    const $inputs = gridContent.querySelectorAll('input');
    $inputs.forEach(input => {
      if (input.checked) {
        input.closest('span').classList.remove('hidden');
        input.closest('.card').classList.add('border-primary');
      }
    });

    // 이벤트 위임 방식으로 카드의 호버 이벤트 처리
    gridContent.addEventListener('mouseover', (event) => {
      const card = event.target.closest('.card');
      if (card) {
        card.classList.add('border-primary'); // 카드 테두리 강조
        const span = card.querySelector('span');
        const checkbox = span?.querySelector('input');
        if (span) {
          span.classList.remove('hidden'); // 체크박스 보이기
        }
      }
    });

    gridContent.addEventListener('mouseout', (event) => {
      const card = event.target.closest('.card');
      if (card) {
        const span = card.querySelector('span');
        const checkbox = span?.querySelector('input');
        if (span && !checkbox.checked) {
          span.classList.add('hidden'); // 체크박스 숨기기
          card.classList.remove('border-primary'); // 카드 테두리 원래대로
        }
      }
    });

    // 각 체크박스에 이벤트 리스너 추가
    const checkboxes = document.querySelectorAll('#grid_content .form-check-input');
    checkboxes.forEach(checkbox => {
      checkbox.addEventListener('click', (event) => {
        event.stopPropagation();
      });
      checkbox.addEventListener('change', (event) => {
        const itemValue = checkbox.getAttribute('value'); // checkbox 자체에서 속성을 가져옴
        if (event.target.checked) { // 체크 상태인 경우에만 실행
          document.getElementById('rp_title').textContent = itemValue;
          fetchItemThumbnailAndDetails(current_path + '/' + itemValue);
          store.dispatch({ type: "ADD_SELECTED_ITEM", payload: itemValue });
        } else { // 체크 해제된 경우
          store.dispatch({ type: "REMOVE_SELECTED_ITEM", payload: itemValue });
        }
      });
    });
  }

  function generateBreadcrumbFromPath() {
    const current_path = store.getState().current_path;
    const $breadcrumb = document.getElementById('breadcrumb');
    const splited_path = current_path.split('/').filter(path => path);
 
    const html_for_crumb = splited_path.map((_, index) => {
      const path = splited_path.slice(0, index + 1).join('/');
      const dir_name = splited_path[index];
      const isActive = index === splited_path.length - 1;
      
      return `
        <li data-path="${path.startsWith('/') ? path.slice(1) : path }" class="breadcrumb-item ${isActive ? 'active fw-semibold' : 'fw-light mobile'}" ${isActive ? 'aria-current="page"' : ''}>${dir_name}</li>
      `;
    }).join('');

    $breadcrumb.innerHTML = '<li data-path="" id="home" class="breadcrumb-item fw-light" >Home</li>' + html_for_crumb;
    const $breadcrumbs = document.querySelectorAll('#breadcrumb li');
    $breadcrumbs.forEach(li => {
      li.addEventListener('click', async (e) => {
        e.stopPropagation();
        toc_flag = false;
        await fetchDirectoryDetails(li.dataset.path);
        await updateAndActivateDirectoryTreeItem();
        toc_flag = true;
      });
    });
  }

  async function updateAndActivateDirectoryTreeItem() {
    const state = store.getState();
    const currentPath = state.current_path.startsWith('/') 
      ? state.current_path.substring(1) 
      : state.current_path;
      
    const directoryItem = state.directoryTree.find(item => item.path === currentPath);
    const id = directoryItem?.id;

    if (id) {
      const $elem = document.querySelector(`#toc a[data-id="${id}"]`);
      const $icon = $elem.querySelector('.fa-solid');

      if (!$icon.classList.contains('fa-folder-open')) {
        $elem.click();
      }
    }
  }

  function reducer(state, action) {
    if (state === undefined) {
      return {
        directoryTree: [],
        view_contents: [],
        current_path: '',
        selectedItems: [], // 선택된 항목들
      }
    }
    let newState;
    if (action.type === 'UPDATE'){
      if (action.target === 'nav_dir') {
        const newContents = [...action.content];
        newState = Object.assign({}, state, {
          directoryTree: newContents,
        });
      } else if (action.target === 'file_list') {
        const newContents = [...action.content];
        newState = Object.assign({}, state, {
          view_contents: newContents,
          current_path: action.dir,
          selectedItems: [],
        });
      } else if (action.target === 'breadcrumb') {
        const pathLen = state.current_path.split('/');
        if (pathLen.length > 0) {
          const updatedPath = pathLen.slice(0, pathLen.length - 1).join('/');
          newState = Object.assign({}, state, {
            current_path: updatedPath,
            selectedItems: [],
          });
        }
      } else if (action.target === 'sort_table') {
        const sortByRule = (rule, oddEven) => (a, b) => {
          const num = oddEven == 'odd' ? -1 : 1;
          if (a[rule] === b[rule]) {
            return 0;
          } 
          return a[rule] > b[rule] ? 1 * num : -1 * num;
        }
        let key = null;
        switch (action.rule) {
          case 'type':
            key = '_type';
            break;
          case 'size':
            key = '_size';
            break;
          case 'name':
            key = '_name';
            break;
          case 'date':
            key = '_modified'
            break;
          default:
            return;
        }
        const newContents = [...state.view_contents].sort(sortByRule(key, action.count));
        newState = Object.assign({}, state, {
          view_contents: newContents,
        });        
      }
    } else if (action.type === 'ADD_SELECTED_ITEM') {
      newState = {
        ...state,
        selectedItems: [...state.selectedItems, action.payload],
      };
    } else if (action.type === 'REMOVE_SELECTED_ITEM') {
      newState ={
        ...state,
        selectedItems: state.selectedItems.filter(
          (item) => item != action.payload
        ),
      };
    } else if (action.type === 'ADD_SELECTED_ITEMS') {
      newState = {
        ...state,
        selectedItems: [...state.selectedItems, ...action.payload],
      };
    } else if (action.type === 'REMOVE_SELECTED_ITEMS') {
      newState ={
        ...state,
        selectedItems: [...state.selectedItems].filter(
          (item) => ![...action.payload].includes(item)
        ),
      };
    } else if (action.type === 'DELETE_SELECTED_ITEMS') {
      newState = {
        ...state,
        view_contents: [...state.view_contents].filter(
          (item) => !(action.payload || []).includes(item['_name']) // undefined 방지
        ),
        directoryTree: [...state.directoryTree].filter(
          (item) => !(action.dir || []).includes(item['id'])
        ),
      };
    }
    return newState;
  }

  const productionURL = 'http://121.189.157.152:8080';
  const testURL = 'http://127.0.0.1:8080';
  const localURL = 'http://172.30.1.25:8080';
  let _URL = null;
  if (window.location.href.split('/')[2] === '127.0.0.1:8080'){
    _URL = testURL;
  } else if (window.location.href.split('/')[2] === '172.30.1.25:8080'){
    _URL = localURL;
  } else {
    _URL = productionURL;
  }

  const fetchDirectoryContents = async () => {
    const state = store.getState();
    const url = `${_URL}/cloudstorage/directoryContents/`;
    
    try {
      const response = await fetch(url, { method: 'GET' });
      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      if (response.status === 204) {
        console.log('No Content');
        return;
      }

      const res = await response.json();
      const directoryTree = res.message.map((item, idx) => {
        const isFile = item.includes('.');
        const num = item.split('/').length - 1; 
        const _path = item.split('/').pop();
        return {
          id: idx + 1,
          path: item,
          pathForDisplay: _path,
          subdirectoryDepth: num,
          type: isFile ? 'file' : 'directory',
          children: [],
        };
      });

      directoryTree.forEach((elem) => {
        const children = directoryTree.filter(item => 
          item.path.startsWith(`${elem.path}/`) && item.path !== elem.path
          && !item.path.split(`${elem.path}/`)[1].includes('/')
        );
        const children_ids = children.map(child => child.id);
        elem.children = children_ids;
      });

      store.dispatch({ type: 'UPDATE', target: 'nav_dir', content: directoryTree });
    } catch (error) {
      console.error('Error:', error);
    }
  };

  const fetchDirectoryDetails = async (dir_path) => {
    const $target = document.getElementById('my_table').classList.contains('invisible') ? document.getElementById('my_grid') : document.getElementById('my_table');
    $target.classList.add('invisible');
    document.getElementById('placeholder').classList.add('d-flex');
    document.getElementById('placeholder').classList.remove('invisible');
    
    const state = store.getState();
    const url = `${_URL}/cloudstorage/listDirectoryDetails/${dir_path}`;
    
    try {
      const response = await fetch(url, { method: 'GET' });
      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      if (response.status === 204) {
        console.log('No Content');
        return;
      }

      const res = await response.json();
      $target.classList.remove('invisible');
      document.getElementById('placeholder').classList.add('invisible');
      document.getElementById('placeholder').classList.remove('d-flex');
      store.dispatch({ type: 'UPDATE', target: 'file_list', content: res.message, dir: dir_path });
      initializeTableHeader();
      document.getElementById('rp_title').textContent = dir_path;
      await fetchItemThumbnailAndDetails(dir_path);
    } catch (error) {
      console.error('Error:', error);
    }
  };

  const fetchDriveStorageInfo = async () => {
    const state = store.getState();
    const url = `${_URL}/cloudstorage/getDriveUsage/`;
    
    try {
      const response = await fetch(url, { method: 'GET' });
      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      if (response.status === 204) {
        console.log('No Content');
        return;
      }

      const res = await response.json();
      // used, total, storage_bar
      const used_percentage = parseInt(parseFloat(res.message.used_gb) / parseFloat(res.message.total_gb) * 100);
      document.getElementById('used').textContent = res.message.used_gb.toFixed(2) + 'GB';
      document.getElementById('total').textContent = res.message.total_gb.toFixed(2) + 'GB';
      document.getElementById('storage_bar').style.width = used_percentage + '%';
      document.getElementById('storage_bar').textContent = used_percentage + '%';
    } catch (error) {
      console.error('Error:', error);
    }
  }

  const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
  window.store = store;
  // store.subscribe(TOC);
  store.subscribe(article);
  store.subscribe(grid_article);
  store.subscribe(updateButtonIconBasedOnCheckboxes);
  store.subscribe(generateBreadcrumbFromPath);

  window.onload = async function(){
    await fetchDirectoryContents();
    await fetchDirectoryDetails('');
    await fetchDriveStorageInfo();
    TOC();

    document.getElementById('toggleButton').addEventListener('click', () => {
      store.dispatch({ type: 'UPDATE', target: 'breadcrumb'});
      fetchDirectoryDetails(store.getState().current_path);
    });

    const rightPanel = document.getElementById('right_panel');
    document.getElementById('infoToggleBtn').addEventListener('click', () => {
      rightPanel.classList.toggle('hidden'); // .hidden 클래스 추가
    });
    
    const $my_table = document.getElementById('my_table');
    const $my_grid = document.getElementById('my_grid');
    const $tableBtn = document.getElementById('tableBtn');
    const $gridBtn = document.getElementById('gridBtn');

    // 버튼 및 콘텐츠 전환 함수
    function toggleMode(activeBtn, inactiveBtn, showElement, hideElement) {
      activeBtn.classList.add('currentMode');
      inactiveBtn.classList.remove('currentMode');
      showElement.classList.remove('invisible');
      hideElement.classList.add('invisible');
    }

    // 이벤트 리스너 설정
    $tableBtn.addEventListener('click', () => {
      if (!$tableBtn.classList.contains('currentMode')) {
        toggleMode($tableBtn, $gridBtn, $my_table, $my_grid);
      }
    });

    $gridBtn.addEventListener('click', () => {
      if (!$gridBtn.classList.contains('currentMode')) {
        toggleMode($gridBtn, $tableBtn, $my_grid, $my_table);
      }
    });

    document.getElementById('toggleAllCheckboxId').addEventListener('click', (e) => {
      const { selectedItems, view_contents } = store.getState();
      const $checkboxes = document.querySelectorAll('#my_table td input');
      let itemName = [];
      $checkboxes.forEach(checkbox => {
        itemName.push(checkbox.value);
      });
      if (selectedItems.length == 0) { // 모든 요소 선택 후, 체크박스 아이콘으로 변경
        store.dispatch({ type: "ADD_SELECTED_ITEMS", payload: itemName });
      } else { // 모든 요소 해제 후, 빈 상자 아이콘으로 변경
        store.dispatch({ type: "REMOVE_SELECTED_ITEMS", payload: itemName });
      }
    });
    
    document.getElementById('downloadBtn').addEventListener('click', async () => {
      const state = store.getState();
      const { selectedItems, current_path } = state;
      const progressBar = document.getElementById('downloadProgress'); // 진행률 바

      try {
        for (const file_name of selectedItems) {
          const file_path = current_path + '/' + file_name;
          const url = `${_URL}/cloudstorage/sendFileResponse/${file_path}`;
          
          // fetch 요청 (HEADERS 포함)
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP error! Status: ${response.status}`);

          // 파일 크기 가져오기
          const contentLength = response.headers.get('Content-Length');
          if (!contentLength) throw new Error("Cannot determine file size.");
          const totalSize = parseInt(contentLength, 10);

          // 🔥 스트리밍 다운로드 설정
          const reader = response.body.getReader();
          let receivedSize = 0; // 받은 데이터 크기
          let chunks = []; // 청크 저장

          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            chunks.push(value);
            receivedSize += value.length;

            // 진행률 계산 및 표시
            const progress = Math.round((receivedSize / totalSize) * 100);
            progressBar.style.width = progress + "%";
            progressBar.innerText = progress + "%";
          }

          // Blob 생성 및 다운로드 실행
          const blob = new Blob(chunks);
          const a = document.createElement('a');
          a.href = URL.createObjectURL(blob);
          a.download = file_name;
          document.body.appendChild(a);
          a.click();
          document.body.removeChild(a);
        }

        // 다운로드 완료 후 진행률 초기화
        progressBar.style.width = "0%";
        progressBar.innerText = "0%";

        $('#toggleAllCheckboxId').click();
      } catch (error) {
        console.error('Error: ', error);
      }
    });

    document.getElementById('confirmDeleteBtn').addEventListener('click', async () => {
      const state = store.getState();
      const { selectedItems, current_path } = state;

      if (selectedItems.length === 0) {
        console.warn("No items selected for deletion.");
        return;  // 선택된 항목이 없으면 실행하지 않음
      }
      $('#toggleAllCheckboxId').click()
      try {
        const url = `${_URL}/cloudstorage/deleteResource/`;
        // Promise.all을 사용하여 여러 개의 삭제 요청을 병렬로 처리
        const responses = await Promise.all(selectedItems.map(async (file_name) => {
          const file_path = `${current_path}/${file_name}`.startsWith('/') ? `${current_path}/${file_name}`.slice(1) : `${current_path}/${file_name}`;
          const data = { path: file_path };

          const options = {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(data),
          };

          const response = await fetch(url, options);
          if (!response.ok) {
            throw new Error(`Failed to delete ${file_name}: ${response.statusText}`);
          }
          return response.json();  // JSON 응답 반환
        }));

        // 삭제된 파일들 출력 (모든 요청 완료 후 실행)
        responses.forEach((res) => console.log(res.message));
        
        const del_dir = selectedItems.filter(item => !item.includes('.')).map(item => `${current_path}/${item}`.startsWith('/') ? `${current_path}/${item}`.slice(1) : `${current_path}/${item}`);
        let delIds = [...state.directoryTree].filter(item => del_dir.includes(item.path)).map(item => item.id.toString());
        const dirs = document.querySelectorAll('ul#toc a');
        dirs.forEach(el => {
          if (delIds.includes(el.dataset.id)) {
            const subids = JSON.parse(el.dataset.subids).map(el => el.toString());
            delIds = [...delIds, ...subids];
            el.remove();
          } 
        });

        delIds = delIds.map(item => parseInt(item));
        store.dispatch({ type: "DELETE_SELECTED_ITEMS", payload: selectedItems, dir: delIds});
        await fetchDriveStorageInfo();
        $('#deleteModal').modal('hide');
      } catch (error) {
        console.error('Error deleting files:', error);
      }
    });

    // '새 폴더' 모달창의 세부 항목의 내용 지정하기
    const $createFolderModal = document.getElementById('createFolderModal')
    if ($createFolderModal) {
      $createFolderModal.addEventListener('show.bs.modal', event => {
        // Button that triggered the modal
        const button = event.relatedTarget
        // Extract info from data-bs-* attributes
        const recipient = button.getAttribute('data-bs-whatever')
        const modalTitle = $createFolderModal.querySelector('.modal-title')
        const modalBodyInput = $createFolderModal.querySelector('.modal-body input')
        modalTitle.textContent = `새 폴더 만들기`;
        modalBodyInput.value = '';
      })
    }

    // '삭제' 모달창의 세부 항목의 내용 지정하기
    const $deleteModal = document.getElementById('deleteModal');
    if ($deleteModal) {
      $deleteModal.addEventListener('show.bs.modal', event => {
        const button = event.relatedTarget;
        const recipient = button.getAttribute('data-bs-whatever');
        const state = store.getState();
        const { selectedItems, current_path } = state;
        
        if (selectedItems.length == 1 && !selectedItems[0].includes('.')) {
          $('#deleteModalLabel').html(`<i class="fa-solid fa-triangle-exclamation" style="color: red;"></i>&nbsp;${JSON.stringify(selectedItems).slice(1, -1)}과(와) 모든 하위폴더를 삭제하시겠습니까?`);
        } else {
          $('#deleteModalLabel').html(`<i class="fa-solid fa-triangle-exclamation" style="color: red;"></i>&nbsp;${selectedItems.length}개의 항목을 삭제합니다.`);
        }
      });
    }

    // 모달창에서 '정하기'를 클릭했을 시, 입력한 이릉의 폴더가 current_path 하위에 생성되도록 서버에 요청하기
    document.getElementById('createFolderForm').addEventListener('submit', async (e) => {
      e.preventDefault();
      const dir_name = e.target.querySelector('input').value;
      const { current_path, directoryTree } = store.getState();
      try {
        const url = `${_URL}/cloudstorage/createFolderAtPath/`;
        const dir_path = `${current_path}/${dir_name}`.startsWith('/') ? `${current_path}/${dir_name}`.slice(1) : `${current_path}/${dir_name}`;
        const data = { path: dir_path };

        const options = {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data),
        };

        const response = await fetch(url, options);
        if (!response.ok) {
          throw new Error(`Failed to create ${dir_path}: ${response.statusText}`);
        }
        const msg = await response.json();
        // console.log(msg.message);
        await fetchDirectoryContents();

        const path = current_path.startsWith('/') ? current_path.slice(1) : current_path;
        const splited_path = path.split('/').filter(_path => _path);
        const path_for_activate = splited_path.map((_, index) => splited_path.slice(0, index + 1).join('/'));
        TOC(path_for_activate);
        const p = path_for_activate.pop();
        const dirElem = directoryTree.filter(item => item.path == p).map(item => item.id)[0];
        document.querySelector(`ul#toc a[data-id="${dirElem}"]`).click();
        
        $('#createFolderModal').modal('hide');
      } catch (error) {
        console.error('Error creating new folder:', error);
      }
    });

    const inputField = document.getElementById('folder_name');
    let isComposing = false; // IME 입력 중 여부를 저장

    // 한글 입력 조합 시작
    inputField.addEventListener('compositionstart', function () {
      isComposing = true;
    });

    // 한글 입력 조합 완료
    inputField.addEventListener('compositionend', function (event) {
      isComposing = false;
      event.target.value = event.target.value.replace(/[^a-zA-Z0-9가-힣\s]/g, ''); // 최종 검증
    });

    // 입력 이벤트 처리 (IME 입력 중이 아닐 때만 실행)
    inputField.addEventListener('input', function (event) {
      if (!isComposing) {
        event.target.value = event.target.value.replace(/[^a-zA-Z0-9가-힣\s]/g, '');
      }
    });
  }
</script>
{% endblock %}