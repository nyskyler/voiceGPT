{% extends "base2.html" %}
{% block content %}
<style>
  :root {
    --border-thickness: 0.4rem;
  }

  body {
    font-family: sans-serif;
    margin: 0;
  }

  table {
    border-collapse: collapse;
    width: 100%;
  }

  td {
    border: 1px solid #ddd;
    padding: 4px 8px;
  }

  #thead {
    position: sticky;
    top: 0;
    /* í—¤ë” ë°°ê²½ìƒ‰ ì„¤ì • */
    z-index: 1;
    /* ë‹¤ë¥¸ ì½˜í…ì¸ ë³´ë‹¤ ìœ„ì— í‘œì‹œë˜ë„ë¡ ì„¤ì • */
  }
  #thead th {
    background: #FEFF04;
  }

  #thead::after {
    content: "";
    display: block;
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background-color: #343434;
  }

  #mainRow {
    display: flex;
    flex-direction: row;
    height: 94vh;
  }

  /* === ì‚¬ì´ë“œë°”: ì´ˆê¸° ê³ ì • ë„ˆë¹„ë¥¼ ì¤€ë‹¤ (flex-basisëŠ” ì• ë‹ˆë©”ì´ì…˜ ëŒ€ìƒ) === */
  .sideBar {
    display: flex;
    flex-direction: column;
    flex: 0 0 240px;
    /* ì´ˆê¸° ë„ˆë¹„ (í”½ì…€ë¡œ ê³ ì •) */
    width: 240px;
    /* ì¼ë¶€ ë¸Œë¼ìš°ì € í˜¸í™˜ìš© */
    min-width: 0;
    /* ì¶•ì†Œ í—ˆìš© (ì¤‘ìš”!) */
    overflow: hidden;
    /* ë‚´ë¶€ ë‚´ìš©ì´ ì‚ì ¸ë‚˜ì˜¤ì§€ ì•Šê²Œ */
    box-sizing: border-box;
    transition: flex-basis 400ms ease, width 400ms ease, padding 300ms ease;
    padding: 8px;
    background: #F2F0EF;
  }

  /* ìˆ¨ê¸¸ ë•Œ: flex-basisë¥¼ 0ìœ¼ë¡œ ì¤„ì´ë©´ ë‹¤ë¥¸ ì•„ì´í…œì´ ê³µê°„ì„ ì±„ì›€ */
  .sideBar-hidden {
    flex-basis: 0 !important;
    width: 0 !important;
    padding: 0 !important;
    overflow: hidden;
  }

  /* ë©”ì¸ ì»¨í…ì¸ : ë‚¨ì€ ê³µê°„ì„ ìë™ìœ¼ë¡œ ì±„ìš°ë„ë¡ í•˜ê³  ìµœì†Œ ë„ˆë¹„ 0 ì„¤ì •(ì¤‘ìš”) */
  #wrap {
    display: flex;
    flex-direction: column;
    flex: 1 1 auto;
    min-width: 0;
    /* ì¤‘ìš”: ë‚´ë¶€ ìŠ¤í¬ë¡¤/ì˜¤ë²„í”Œë¡œìš°ë¥¼ ì œëŒ€ë¡œ ë™ì‘ì‹œí‚¤ë ¤ë©´ í•„ìš” */
    transition: margin 300ms ease;
    position: relative;
  }

  #nav {
    padding: 0px;
  }

  #toggleBtn {
    position: absolute;
    top: 50%;
    /* ì„¸ë¡œ ì¤‘ì•™ */
    left: 0;
    /* #wrapì˜ ì™¼ìª½ ëª¨ì„œë¦¬ */
    transform: translateY(-50%);
    /* ì„¸ë¡œ ì¤‘ì•™ ì •ë ¬ ë³´ì • */
    z-index: 1000;
    /* ë‹¤ë¥¸ ìš”ì†Œ ìœ„ë¡œ */
    color: #ffffff;
    background-color: #263574;
    border-radius: 0% 13% 13% 0%;
    height: 3.5rem;
    padding: 1.5px 4px;
    border: none;
    cursor: pointer;
  }

  /* chart / info ì˜ì—­ (ê¸°ì¡´ ìŠ¤íƒ€ì¼ ìœ ì§€) */
  #chart_section {
    flex: 3;
    background: snow;
    display: flex;
    justify-content: center;
    align-items: center;
    min-width: 0;
    padding-left: 1rem;
    border-left: var(--border-thickness, 0.2rem) solid #343434;
  }

  #info_section {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-width: 0;
    border-right: var(--border-thickness, 0.2rem) solid #343434;
    background: #FAF6EB;
  }

  #table_section {
    flex: 2;
    overflow-y: auto;
    padding: 0rem;
  }

  #currentValue_section {
    flex: 1;
    overflow-y: auto;
    /* ì„¸ë¡œ ìŠ¤í¬ë¡¤ ìë™ ìƒì„± */
    padding: 0.3rem;
    /* ì¹´ë“œê°€ ë²½ì— ë¶™ì§€ ì•Šë„ë¡ ì—¬ë°± */
  }

  #currentValue_section .card {
    margin-bottom: 0.5rem;
    /* ì¹´ë“œ ì‚¬ì´ ê°„ê²© */
  }

  #currentValue_section .card-title {
    font-size: 1rem;
    /* ì œëª©ì€ ë³´í†µ í¬ê¸° */
  }

  #currentValue_section .card-text {
    font-size: 1.5rem;
    /* ê°’ì€ í¬ê²Œ ê°•ì¡° */
    font-weight: bold;
  }

  /* í—¤ë”/í‘¸í„° */
  #wrap>div:first-child {
    flex: 0 0 5%;
    /* background: #eb4a24;  */
    background: #CB302A;
    display: flex;
    align-items: center;
    padding-left: 10px;
    color: white;
    font-weight: bold;
    border: var(--border-thickness, 0.2rem) solid #343434;
    border-top: 0rem;
  }

  #wrap>div:nth-child(2) {
    flex: 1;
    display: flex;
    flex-direction: row;
    min-height: 0;
  }

  #wrap>div:nth-child(3) {
    flex: 0 0 5%;
    background: #0C5A9D;
    display: flex;
    align-items: center;
    justify-content: space-between;
    font-weight: bold;
    color: snow;
    border: var(--border-thickness, 0.2rem) solid #343434;
    border-bottom: 0rem;
  }

  /* ì•„ì´ì½˜ íšŒì „(ì„ íƒì‚¬í•­) */
  #btnIcon {
    transition: transform 300ms ease;
  }

  .rotated {
    transform: rotate(180deg);
  }

  .accordion-body {
    padding: 0.3rem 0rem 0.3rem 0.6rem;
    border-top: 0.5px solid #cecfd1;
  }

  .list-group-item:hover,
  .accordion-button:hover {
    color: #3d64dc;
  }

  .list-group-item {
    font-size: 0.8rem;
    color: #68758E;
    padding: 0.3rem 0rem 0.3rem 0.5rem;
    border: none;
    cursor: pointer;
  }

  .accordion-button {
    color: #393372;
    padding: 0.5rem 1rem 0.5rem 0.6rem;
  }

  .list-group-item.active {
    color: #3d64dc;
    background-color: transparent;
  }

  .breadcrumb {
    margin-bottom: 0;
    padding: 0;
    /* ìƒí•˜ ì—¬ë°± ì œê±° */
  }

  #macAddr {
    cursor: pointer;
  }

  /* (ì„ íƒ) ê°•ì¡° í•´ì œê°€ ë¶€ë“œëŸ½ê²Œ ë³´ì´ë„ë¡ ê¸°ë³¸ ìƒíƒœì—ë„ transition ì¶”ê°€ */
  #tbl tbody td,
  #tbl tbody th {
    transition: background-color 0.5s ease;
  }
  #tbl {
    margin-bottom: 0;
  }

  /* --- êµ¬ë¶„ì„  ìŠ¤íƒ€ì¼ --- */
  .divider-vertical {
    width: var(--border-thickness, 0.2rem);
    background: #343434;
    cursor: col-resize;
  }

  .divider-horizontal {
    height: var(--border-thickness, 0.2rem);
    background: #343434;
    cursor: row-resize;
  }
  #footer-left {
    display: flex;
    gap: 0.5rem;
    padding: 0.5rem;
  }
  #footer-right {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
    align-items: center;
    padding: 0.5rem;
  }
  label {
    font-size: 0.9rem;
  }
  select, input[type="range"] {
    margin-left: 0.3rem;
  }

  .xmode-btn {
    border: 1px solid #fff;
    border-radius: 999px;
    background: transparent;
    color: #fff;
    padding: 4px 12px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .xmode-btn:hover {
    background: rgba(255, 255, 255, 0.15);
  }

  .xmode-btn.active {
    background: #fff;
    color: #000;
    font-weight: 600;
  }

  .card-title input[type="checkbox"] {
    transform: scale(1.3);
    vertical-align: middle;
  }

  @media (min-width: 1024px) and (max-width: 1366px) {
  /* ì•„ì´íŒ¨ë“œ í”„ë¡œ 12.9ì¸ì¹˜ í™”ë©´ì—ë§Œ ì ìš©í•  ìŠ¤íƒ€ì¼ */
    #mainRow {
      display: flex;
      flex-direction: row;
      height: 86.5vh;
    }
  }

    /* âœ… ëª¨ë°”ì¼ ëŒ€ì‘ */
  @media (max-width: 768px) and (orientation: portrait) {
    #mainRow {
      flex-direction: column;
      height: 81.7vh; /* ëª¨ë°”ì¼ì—ì„œëŠ” ì „ì²´ í™”ë©´ ë†’ì´ë¡œ ì„¤ì • */
      overflow-y: hidden;
    }

    .sideBar {
      display: none !important;
    }

    #toggleBtn {
      display: none !important;
    }

    .divider-vertical {
      display: none !important;
    }

    .divider-horizontal {
      display: none !important;
    }

    /* í—¤ë”ì— ë©”ë‰´ ë²„íŠ¼ ì¶”ê°€ ê³µê°„ í™•ë³´ */
    #wrap>div:first-child {
      justify-content: space-between;
      /* padding-right: 1rem; */
    }

    #wrap>div:nth-child(2) {
      flex-direction: column;
    }

    /* chart ìœ„, info ì•„ë˜ë¡œ ë°°ì¹˜ */
    #chart_section {
      flex: 1;
      border-left: none;
      border-bottom: var(--border-thickness) solid #343434;
      padding: 0.5rem;
    }

    #info_section {
      flex: 0;
      flex-direction: row;
      /* height: 50vh; */
      border-right: none;
    }

    /* í…Œì´ë¸” ì„¹ì…˜ ìˆ¨ê¸°ê¸° */
    #table_section {
      display: none !important;
    }
    /* currentValue_sectionì„ ê°€ë¡œ ìŠ¤í¬ë¡¤ ê°€ëŠ¥í•˜ê²Œ ë³€ê²½ */
    #currentValue_section {
      display: flex;
      flex-direction: row;
      flex-wrap: nowrap; /* ì¤„ë°”ê¿ˆ ê¸ˆì§€ */
      overflow-x: auto;  /* ì¢Œìš° ìŠ¤í¬ë¡¤ í—ˆìš© */
      overflow-y: hidden;
      -webkit-overflow-scrolling: touch; 
      scroll-behavior: smooth;
      gap: 0.5rem;
      text-align: center;
      align-items: center;
      margin-top: 0.45rem;
    }

    /* ì¹´ë“œë“¤ì„ ì»¨í…ì¸  í¬ê¸°ì— ë§ê²Œ ì¤„ì´ê¸° */
    .card {
      flex: 1 1 auto; /* ê³ ì • í¬ê¸° (ì¤„ë°”ê¿ˆ X) */
      min-width: unset; /* ìµœì†Œ ë„ˆë¹„ ì œí•œ í•´ì œ */
      width: auto; /* ë‚´ìš© ê¸¸ì´ì— ë§ê²Œ */
      /* padding: 10px 16px; */
      white-space: nowrap; /* í…ìŠ¤íŠ¸ ì¤„ë°”ê¿ˆ ë°©ì§€ */
      height: 100%; 
    }

    /* footer êµ¬ì„± */
    #wrap>div:nth-child(3) {
      flex-direction: column;
      align-items: flex-start;
      justify-content: flex-start;
      gap: 0.5rem;
    }
    #footer-left {
      width: 100%;
      justify-content: center;
      /* flex-wrap: wrap; */
    }
    #footer-right {
      display: none !important;
    }

    /* ëª¨ë°”ì¼ ë©”ë‰´ ë²„íŠ¼ */
    .mobile-menu-btn {
      display: inline-block;
      background: #fff;
      color: #CB302A;
      border: none;
      border-radius: 6px;
      padding: 4px 10px;
      font-weight: 600;
    }
  }
</style>

<!-- ê¸°ì¡´ êµ¬ì¡° ìœ ì§€ -->
<div class="container-fluid" style="padding: 0px;">
  <div id="mainRow">
    <div id="nav" class="sideBar col-12 col-sm-3 col-xl-2">
      <div class="accordion accordion-flush" id="accordionFlushExample">
      </div>
    </div>
    <div id="wrap" class="col-12 col-sm-9 col-xl-10">
      <div>
        <nav
          style="--bs-breadcrumb-divider: url(&#34;data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='8' height='8'%3E%3Cpath d='M2.5 0L1 1.5 3.5 4 1 6.5 2.5 8l4-4-4-4z' fill='%236c757d'/%3E%3C/svg%3E&#34;);"
          aria-label="breadcrumb">
          <ol class="breadcrumb">
            <li id="macAddr" class="breadcrumb-item" onclick="$('#systemBtn').click()"></li>
            <li class="breadcrumb-item active" aria-current="page"></li>
          </ol>
        </nav>

        <!-- âœ… ëª¨ë°”ì¼ ë©”ë‰´ ë²„íŠ¼ -->
        <button class="mobile-menu-btn d-md-none fs-5" type="button" data-bs-toggle="offcanvas" data-bs-target="#mobileNav" style="margin: 0.4rem;">
          <i class="fa-solid fa-arrow-right-to-bracket"></i>
        </button>
      </div>
      <div style="display:flex; flex:1; min-height:0;">
        <div id="chart_section">
          <canvas id="myChart"></canvas>
        </div>

        <!-- ì¢Œìš° êµ¬ë¶„ì„  -->
        <div id="vDivider" class="divider-vertical"></div>

        <div id="info_section">
          <div id="table_section">
            <table id="tbl" class="table table-light table-striped" style="width:100%; border-collapse:collapse;">
              <thead id="thead"></thead>
              <tbody id="tbody" class="text-end"></tbody>
            </table>
          </div>

          <!-- ìƒí•˜ êµ¬ë¶„ì„  -->
          <div id="hDivider" class="divider-horizontal"></div>

          <div id="currentValue_section"></div>
        </div>
      </div>
      <!-- xì¶• ë‹¨ìœ„ ì„ íƒ í‘¸í„° -->

      <div id="footer">
        <!-- ì¢Œì¸¡: xmode ë²„íŠ¼ -->
        <div id="footer-left">
          <button class="xmode-btn" data-mode="ms">ë°€ë¦¬ì´ˆ</button>
          <button class="xmode-btn active" data-mode="s">ì´ˆ</button>
          <button class="xmode-btn" data-mode="m">ë¶„</button>
          <button class="xmode-btn" data-mode="h">ì‹œ</button>
          <button class="xmode-btn" data-mode="Hm">ì‹œê°„</button>
          <button class="xmode-btn" data-mode="ymdHm">ë‚ ì§œ+ì‹œê°„</button>
        </div>

        <!-- ìš°ì¸¡: ì°¨íŠ¸ ì˜µì…˜ -->
        <div id="footer-right">
          <!-- 1ï¸âƒ£ tension -->
          <label>ê³¡ì„ (tension): 
            <input id="opt-tension" type="range" min="0" max="1" step="0.1" value="0.2">
            <span id="tension-value">0.2</span>
          </label>

          <!-- 2ï¸âƒ£ pointStyle -->
          <label>í¬ì¸íŠ¸: 
            <select id="opt-pointstyle">
              <option value="circle">circle</option>
              <option value="crossRot">crossRot</option>
              <option value="dash">dash</option>
              <option value="line">line</option>
              <option value="rect">rect</option>
              <option value="rectRot">rectRot</option>
              <option value="star">star</option>
              <option value="triangle">triangle</option>
            </select>
          </label>

          <!-- 3ï¸âƒ£  Grid í‘œì‹œ ì˜µì…˜ -->
          <label>ê·¸ë¦¬ë“œ:
            <select id="opt-grid">
              <option value="both">ë‘˜ ë‹¤ í‘œì‹œ</option>
              <option value="none">í‘œì‹œ ì•ˆ í•¨</option>
              <option value="v">ìˆ˜ì§ì„ ë§Œ</option>
              <option value="h">ìˆ˜í‰ì„ ë§Œ</option>
            </select>
          </label>
        </div>
      </div>

      <button id="toggleBtn"><i id="btnIcon" class="fa-solid fa-caret-left fs-6"></i></button>
    </div>
  </div>
</div>

<!-- âœ… ëª¨ë°”ì¼ìš© Offcanvas -->
<div class="offcanvas offcanvas-start" tabindex="-1" id="mobileNav">
  <div class="offcanvas-header">
    <h5 class="offcanvas-title">ë©”ë‰´</h5>
    <button type="button" class="btn-close" data-bs-dismiss="offcanvas"></button>
  </div>
  <div class="offcanvas-body">
    <!-- ê¸°ì¡´ ì•„ì½”ë””ì–¸ ë³µì œ -->
    <div id="mobileAccordionContainer"></div>
  </div>
</div>

<!-- ê¸°ê¸° ë° ì„œë²„ì˜ ì„¤ì •ê°’ì„ ì§€ì •í•˜ëŠ” ëª¨ë‹¬ì°½ -->
<button type="button" id="systemBtn" style="display: none;" class="btn btn-primary" data-bs-toggle="modal"
  data-bs-target="#dataConfigModal" data-bs-whatever="{{ g.user.username }}"></button>
<div class="modal fade" id="dataConfigModal" tabindex="-1" aria-labelledby="dataConfigModalLabel" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h1 class="modal-title fs-5" id="dataConfigModalLabel">ì•„ë‘ì´ë…¸ ë°ì´í„° ìˆ˜ì§‘ ì„¤ì •</h1>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="ë‹«ê¸°"></button>
      </div>

      <div class="modal-body">
        <form id="dataConfigForm" novalidate>
          <!-- A. ë°ì´í„° ì „ì†¡ ê°„ê²© (ms) -->
          <div class="mb-3">
            <label for="sendInterval" class="form-label">
              <i class="fa-regular fa-clock"></i>&nbsp;&nbsp;ë°ì´í„° ì „ì†¡ ê°„ê²©(ms)
            </label>
            <input type="number" class="form-control" id="sendInterval" name="sendInterval" min="2000" step="100"
              value="2000" required>
            <div class="form-text">2000ms ì´ìƒë§Œ í—ˆìš©ë©ë‹ˆë‹¤.</div>
            <div class="invalid-feedback">2000ms ì´ìƒìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”.</div>
          </div>

          <!-- B. ì´ì–´ì“°ê¸° ì—¬ë¶€ (append/overwrite) -->
          <p class="fs-6 mb-1">
            <i class="fa-regular fa-file-lines"></i>&nbsp;&nbsp;ì´ì–´ì“°ê¸°(append) ì—¬ë¶€
          </p>
          <div class="mb-3 d-flex flex-wrap align-items-center justify-content-center gap-3">
            <input class="btn-check" type="radio" name="appendMode" id="appendYes" value="true" autocomplete="off"
              checked>
            <label class="btn btn-outline-primary" for="appendYes">ì˜ˆ (append)</label>

            <input class="btn-check" type="radio" name="appendMode" id="appendNo" value="false" autocomplete="off">
            <label class="btn btn-outline-primary" for="appendNo">ì•„ë‹ˆì˜¤ (overwrite)</label>
          </div>

          <!-- C. ì „ì†¡ íšŸìˆ˜ ì œí•œ -->
          <p class="fs-6 mb-1">
            <i class="fa-regular fa-hashtag"></i>&nbsp;&nbsp;ì „ì†¡ íšŸìˆ˜ ì œí•œ
          </p>
          <div class="mb-3 d-flex align-items-center flex-wrap justify-content-between gap-3">
            <div class="form-check form-switch">
              <input class="form-check-input" type="checkbox" id="sendLimitMode" name="sendLimitOn">
              <label class="form-check-label" for="sendLimitMode">íšŸìˆ˜ ì œí•œ ì‚¬ìš©</label>
            </div>

            <div id="limitCountGroup" class="input-group" style="max-width: 240px;">
              <span class="input-group-text">íšŸìˆ˜</span>
              <input type="number" class="form-control" id="sendLimitCount" name="sendLimitCount" min="1" step="1"
                placeholder="ì˜ˆ: 100" disabled>
              <div class="invalid-feedback">1 ì´ìƒì˜ íšŸìˆ˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”.</div>
            </div>
          </div>

          <!-- D. ë°ì´í„° ì „ì†¡ ì¢…ë£Œ ì‹œì  -->
          <p class="fs-6 mb-1">
            <i class="fa-regular fa-calendar"></i>&nbsp;&nbsp;ë°ì´í„° ì „ì†¡ ì¢…ë£Œ ì‹œì 
          </p>
          <div class="mb-3 d-flex align-items-center justify-content-between gap-3">
            <div class="form-check form-switch">
              <input class="form-check-input" type="checkbox" id="useEndAt" name="useEndAt">
              <label class="form-check-label" for="useEndAt">ì¢…ë£Œ ì‹œì  ì‚¬ìš©</label>
            </div>
            <div style="min-width: 260px;">
              <input type="datetime-local" class="form-control" id="endAt" name="endAt" disabled>
              <div class="invalid-feedback">í˜„ì¬ ì‹œê° ì´í›„ë¡œ ì„ íƒí•˜ì„¸ìš”.</div>
            </div>
          </div>

          <!-- E. í‘œì‹œí•  ë°ì´í„° ê°œìˆ˜ -->
          <div class="mb-3">
            <label for="chartWindow" class="form-label">
              <i class="fa-solid fa-chart-line"></i>&nbsp;&nbsp;í‘œì‹œí•  ë°ì´í„° ê°œìˆ˜
            </label>
            <input type="number" class="form-control" id="chartWindow" name="chartWindow" min="5" max="200" value="50"
              required>
            <div class="form-text">ìµœì†Œ 5, ìµœëŒ€ 200</div>
            <div class="invalid-feedback">5~200 ì‚¬ì´ì˜ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”.</div>
          </div>
        </form>
      </div>

      <div class="modal-footer">
        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">ë‹«ê¸°</button>
        <button type="submit" class="btn btn-primary" form="dataConfigForm">ì €ì¥</button>
      </div>
    </div>
  </div>
</div>
{% endblock %}
{% block script %}
<script type="module">
  import { createStore } from 'https://cdnjs.cloudflare.com/ajax/libs/redux/5.0.1/redux.legacy-esm.js';

  // --- ì „ì—­ ë³€ìˆ˜ ---
  let colorMap = {};
  let chartInstance = null;
  let currentSeries = null;
  let currentBaseTsMs = null;
  let keys = null;
  let filteredSeries = null;
  let sensorSelection = {};
  let jsonFlag = false;
  let currentEventSource = null;

  // ìƒ‰ìƒ íŒ”ë ˆíŠ¸
  const colors = [
    'rgba(54, 162, 235, 1)',
    'rgba(255, 99, 132, 1)',
    'rgba(255, 206, 86, 1)',
    'rgba(75, 192, 192, 1)',
    'rgba(153, 102, 255, 1)',
    'rgba(255, 159, 64, 1)',
  ];

  function formatMac(mac) {
    if (typeof mac !== 'string') {
      throw new TypeError('mac must be a string');
    }

    // ìˆ«ì/ì˜ë¬¸ a-f ì´ì™¸ ì œê±°, ëŒ€ë¬¸ìë¡œ ì •ê·œí™”
    const hex = mac.replace(/[^0-9a-f]/gi, '').toUpperCase();
    if (hex.length !== 12) {
      throw new Error('Invalid MAC address: expected 12 hex characters');
    }

    return hex.match(/.{2}/g).join(':');
  }

  function removeColonsFromMac(mac) {
    return String(mac).replace(/:/g, '');
  }

  function generateAccordionHTMLFromObject(obj) {
    const accordionHTML = Object.entries(obj).map(([mac, files], idx) => {
      return `
        <div class="accordion-item">
          <h2 class="accordion-header">
            <button class="accordion-button collapsed fw-bold" type="button" 
              data-bs-toggle="collapse"
              data-bs-target="#panelsStayOpen-collapse${idx}" aria-expanded="false"
              aria-controls="panelsStayOpen-collapse${idx}">
              <i class="fa-solid fa-wifi me-3 text-primary"></i>${formatMac(mac)}
            </button>
          </h2>
          <div id="panelsStayOpen-collapse${idx}" class="accordion-collapse collapse">
            <div class="accordion-body">
              <ul class="list-group fw-semibold">
                ${files.map(f => `
                  <li class="list-group-item">
                    <i class="fa-solid fa-file-csv me-3 text-success fs-6"></i>${f}
                  </li>
                `).join('')}
              </ul>
            </div>
          </div>
        </div>
      `;
    }).join('');
    return accordionHTML;
  }

  function formatTimestamp(ts) {
    if (!ts) return "";
    const d = new Date(ts);
    if (isNaN(d.getTime())) return ts;
    const yyyy = d.getFullYear();
    const mm = String(d.getMonth() + 1).padStart(2, "0");
    const dd = String(d.getDate()).padStart(2, "0");
    const hh = String(d.getHours()).padStart(2, "0");
    const mi = String(d.getMinutes()).padStart(2, "0");
    const ss = String(d.getSeconds()).padStart(2, "0");
    return `${yyyy}-${mm}-${dd} ${hh}:${mi}:${ss}`;
  }

  // Bootstrap Toast ìœ í‹¸ë¦¬í‹°
  function showToast(title, body, extraClass = '') {
    let container = document.getElementById('toastContainer');
    if (!container) {
      container = document.createElement('div');
      container.id = 'toastContainer';
      container.className = 'toast-container position-fixed top-0 end-0 p-3';
      document.body.appendChild(container);
    }

    const toast = document.createElement('div');
    toast.className = `toast align-items-center border-0 ${extraClass}`;
    toast.setAttribute('role', 'alert');
    toast.setAttribute('aria-live', 'assertive');
    toast.setAttribute('aria-atomic', 'true');

    toast.innerHTML = `
      <div class="d-flex">
        <div class="toast-body">
          <strong class="me-2">${title}</strong><br>${body}
        </div>
        <button type="button" class="btn-close ${extraClass.includes('text-white') ? 'btn-close-white' : ''} me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
      </div>
    `;

    container.appendChild(toast);

    if (window.bootstrap && bootstrap.Toast) {
      const bsToast = new bootstrap.Toast(toast, { delay: 5000 });
      bsToast.show();
      toast.addEventListener('hidden.bs.toast', () => toast.remove());
    } else {
      toast.style.display = 'block';
      setTimeout(() => toast.remove(), 5000);
    }
  }

  // ts ë¬¸ìì—´ì„ Date.parse ê°€ëŠ¥í•œ í˜•íƒœë¡œ ì •ê·œí™” í›„ epoch(ms)ë¡œ ë³€í™˜
  function toEpochMsFromFlaskIso(iso) {
    if (!iso) return NaN;
    let s = String(iso).trim();
    if (s.indexOf('T') === -1 && /\d{4}-\d{2}-\d{2} \d{2}:\d{2}/.test(s)) {
      s = s.replace(' ', 'T');
    }
    s = s.replace(/(\.\d{3})\d+/, '$1'); // JSëŠ” ms(3ìë¦¬)ê¹Œì§€ë§Œ ì•ˆì •ì 
    const t = Date.parse(s);
    return Number.isFinite(t) ? t : NaN;
  }

  // ISO ë¬¸ìì—´ì—ì„œ ë§ë¯¸ì˜ íƒ€ì„ì¡´ ì˜¤í”„ì…‹(+09:00, -04:30 ë“±)ì„ ë¶„ ë‹¨ìœ„ë¡œ ì¶”ì¶œ
  function getOffsetMinutesFromIso(iso) {
    if (!iso) return null;
    const m = String(iso).trim().match(/([+-])(\d{2}):(\d{2})$/);
    if (!m) {
      if (/[zZ]$/.test(iso)) return 0; // Z(UTC)
      return null;
    }
    const sign = m[1] === '-' ? -1 : 1;
    const hh = parseInt(m[2], 10);
    const mm = parseInt(m[3], 10);
    return sign * (hh * 60 + mm);
  }

  // ìƒëŒ€ ë‹¨ìœ„ ë¶„ëª¨
  const UNIT_DENOM = { ms: 1, s: 1000, m: 60_000, h: 3_600_000 };

  // ìˆ«ì í¬ë§· ë³´ì¡°
  function formatByUnit(value, unit) {
    if (unit === 'ms') return Math.round(value);
    const v = Number(value);
    return Number.isInteger(v) ? v : Number(v.toFixed(3));
  }

  // ìë¦¿ìˆ˜ íŒ¨ë”©
  const pad2 = (n) => String(n).padStart(2, '0');

  // ì§€ì •í•œ ì˜¤í”„ì…‹(ë¶„) ê¸°ì¤€ìœ¼ë¡œ epoch(ms)ë¥¼ 'YYYY-MM-DD HH:mm' ë˜ëŠ” 'HH:mm'ë¡œ í¬ë§·
  function formatEpochByOffset(ms, offsetMin, withDate) {
    const tAdj = ms + (offsetMin ?? 0) * 60_000; // UTC ê¸°ì¤€ì— ì˜¤í”„ì…‹ ì ìš©
    const d = new Date(tAdj);
    const Y = d.getUTCFullYear();
    const M = pad2(d.getUTCMonth() + 1);
    const D = pad2(d.getUTCDate());
    const h = pad2(d.getUTCHours());
    const m = pad2(d.getUTCMinutes());
    return withDate ? `${Y}-${M}-${D} ${h}:${m}` : `${h}:${m}`;
  }

  // xì¶• ë¼ë²¨ìš© í¬ë§·í„° ìƒì„±
  function makeTickFormatter(xMode, displayTzOffsetMin) {
    if (xMode === 'ymdHm') {
      return (value) => formatEpochByOffset(Number(value), displayTzOffsetMin, true);
    }
    if (xMode === 'Hm') {
      return (value) => formatEpochByOffset(Number(value), displayTzOffsetMin, false);
    }
    // ìƒëŒ€ ë‹¨ìœ„
    return (value) => `${value}${xMode}`;
  }

  // íˆ´íŒ ì œëª© í¬ë§·í„°
  function makeTooltipTitle(xMode, displayTzOffsetMin) {
    if (xMode === 'ymdHm') {
      return (items) => {
        const v = items?.[0]?.parsed?.x;
        return v != null ? formatEpochByOffset(Number(v), displayTzOffsetMin, true) : '';
      };
    }
    if (xMode === 'Hm') {
      return (items) => {
        const v = items?.[0]?.parsed?.x;
        return v != null ? formatEpochByOffset(Number(v), displayTzOffsetMin, false) : '';
      };
    }
    return (items) => {
      const v = items?.[0]?.parsed?.x;
      return v != null ? `t = ${v}${xMode}` : '';
    };
  }

  // xì¶• íƒ€ì´í‹€ í…ìŠ¤íŠ¸
  function xTitleText(xMode) {
    if (xMode === 'ymdHm') return 'Time (YYYY-MM-DD HH:mm)';
    if (xMode === 'Hm') return 'Time (HH:mm)';
    const map = { ms: 'ms', s: 's', m: 'm', h: 'h' };
    return `Time (${map[xMode] || xMode})`;
  }


  function buildSeriesFromJSON(myJSON, xMode = 's') {
    if (!Array.isArray(myJSON)) return { baseTsMs: NaN, series: {} };

    // ğŸ”¹ key ì •ê·œí™”: BOM ì œê±° + trim
    function normalizeKey(k) {
      return (k || "").replace(/^\uFEFF/, "").trim();
    }

    // ts ì œì™¸í•œ ê°’ keyë“¤ì„ ì¶”ì¶œ (ì •ê·œí™”í•´ì„œ ì¤‘ë³µ ë°©ì§€)
    const valueKeys = Array.from(
      myJSON.reduce((keys, row) => {
        Object.keys(row || {}).forEach((k) => {
          if (k !== 'ts') keys.add(normalizeKey(k));
        });
        return keys;
      }, new Set())
    );

    // baseTsMs ê³„ì‚°
    let baseTsMs = NaN;
    const modeIsRelative = ['ms', 's', 'm', 'h'].includes(xMode);
    if (modeIsRelative && myJSON.length > 0) {
      baseTsMs = toEpochMsFromFlaskIso(myJSON[0].ts);
    }

    const denom = UNIT_DENOM[xMode] ?? UNIT_DENOM.s;
    const series = {};
    valueKeys.forEach((k) => (series[k] = []));

    for (const row of myJSON) {
      const t = toEpochMsFromFlaskIso(row?.ts);
      if (!Number.isFinite(t)) continue;

      const x = modeIsRelative
        ? formatByUnit(Math.max(0, t - baseTsMs) / denom, xMode)
        : t;

      for (const origKey of Object.keys(row || {})) {
        if (origKey === "ts") continue;
        const key = normalizeKey(origKey); // ğŸ”¹ ì—¬ê¸°ì„œë„ ì •ê·œí™”
        const v = Number(row[origKey]);
        if (!Number.isNaN(v)) {
          series[key]?.push({ x, y: v });
        }
      }
    }

    return { baseTsMs, series };
  }

  // --- âœ… ì˜µì…˜ UIì™€ ì°¨íŠ¸ ë™ê¸°í™” ---
  function setupChartOptionControls() {
    const tensionInput = document.getElementById("opt-tension");
    const tensionValue = document.getElementById("tension-value");
    const pointSel = document.getElementById("opt-pointstyle");
    const gridSel = document.getElementById("opt-grid");

    tensionInput.addEventListener("input", () => {
      tensionValue.textContent = tensionInput.value;
      store.dispatch({ type: 'UPDATE', target: 'chartOption_tension', payload: tensionInput.value });
    });

    pointSel.addEventListener("change", () => {
      store.dispatch({ type: 'UPDATE', target: 'chartOption_pointSel', payload: pointSel.value });
    });

    gridSel.addEventListener("change", () => {
      store.dispatch({ type: 'UPDATE', target: 'chartOption_gridSel', payload: gridSel.value });
    });
  }

  // --- âœ… ì°¨íŠ¸ ì˜µì…˜ ì‹¤ì‹œê°„ ë°˜ì˜ ---
  function applyChartOptions() {
    if (!chartInstance) return;
    const { chartOptionsState } = store.getState();
    const { tension, pointStyle, gridMode } = chartOptionsState;

    // ê° datasetì— tension/pointStyle ì ìš©
    chartInstance.data.datasets.forEach(ds => {
      ds.tension = tension;
      ds.pointStyle = pointStyle;
    });

    // --- grid í‘œì‹œ ì œì–´ ---
    // x.grid.display â†’ ìˆ˜ì§ì„  (xì¶• ë°©í–¥ìœ¼ë¡œ ë‚˜ì—´ëœ ì„¸ë¡œì„ )
    // y.grid.display â†’ ìˆ˜í‰ì„  (yì¶• ë°©í–¥ìœ¼ë¡œ ë‚˜ì—´ëœ ê°€ë¡œì„ )
    if (gridMode === 'none') {
      chartInstance.options.scales.x.grid.display = false;
      keys.forEach(key => {
        if (chartInstance.options.scales[key]?.grid) {
          chartInstance.options.scales[key].grid.display = false;
        }
      });
    } else if (gridMode === 'v') {
      // ìˆ˜ì§ì„ ë§Œ í‘œì‹œ (xì¶•ì˜ gridë§Œ í‘œì‹œ)
      chartInstance.options.scales.x.grid.display = true;
      keys.forEach(key => {
        if (chartInstance.options.scales[key]?.grid) {
          chartInstance.options.scales[key].grid.display = false;
        }
      });
    } else if (gridMode === 'h') {
      // ìˆ˜í‰ì„ ë§Œ í‘œì‹œ (yì¶•ì˜ gridë§Œ í‘œì‹œ)
      chartInstance.options.scales.x.grid.display = false;
      keys.forEach(key => {
        if (chartInstance.options.scales[key]?.grid) {
          chartInstance.options.scales[key].grid.display = true;
        }
      });
    } else {
      // ë‘˜ ë‹¤ í‘œì‹œ
      chartInstance.options.scales.x.grid.display = true;
      // console.log(keys)
      keys.forEach(key => {
        if (chartInstance.options.scales[key]?.grid) {
          chartInstance.options.scales[key].grid.display = true;
        }
      });
    }
    chartInstance.update();
  }

  function createLineChart(ctx, series, baseTsMs, myJSON = [], xMode = 's') {
    const { deviceConfig } = store.getState();
    if (chartInstance) {
      chartInstance.destroy();
    }

    // í‘œì‹œìš© íƒ€ì„ì¡´ ì˜¤í”„ì…‹ ê³„ì‚°
    let displayTzOffsetMin = null;
    for (const row of myJSON || []) {
      displayTzOffsetMin = getOffsetMinutesFromIso(row?.ts);
      if (displayTzOffsetMin != null) break;
    }
    if (displayTzOffsetMin == null) {
      displayTzOffsetMin = -new Date().getTimezoneOffset();
    }

    // dataset ìƒì„±
    const datasets = Object.entries(series).map(([key, data], idx) => {
      const color = colors[keys.indexOf(key) - 1 % colors.length];
      // const color = colors[idx % colors.length];
      colorMap[key] = color;
      $('.card').eq(idx).css("background", color);

      return {
        label: key,
        data,
        yAxisID: key,
        borderColor: color,
        backgroundColor: color.replace(/[\d.]+\)$/,'0.1)'),
        tension: 0.2,
        pointRadius: 2,
      };
    });

    // yì¶• ìƒì„±
    const yScales = {};
    Object.keys(series).forEach((key, idx) => {
      yScales[key] = {
        type: 'linear',
        position: idx % 2 === 0 ? 'left' : 'right',
        title: { display: true, text: key },
        grid: { drawOnChartArea: idx === 0 },
      };
    });

    // âœ… Chart.js ì°¨íŠ¸ ìƒì„±
    chartInstance = new Chart(ctx, {
      type: 'line',
      data: { datasets },
      options: {
        parsing: false,
        responsive: true,
        maintainAspectRatio: false, // âœ… ë¹„ìœ¨ ìœ ì§€ ë„ê¸°
        interaction: { mode: 'nearest', intersect: false },
        plugins: {
          tooltip: {
            callbacks: {
              title: makeTooltipTitle(xMode, displayTzOffsetMin),
            },
          },
          legend: { position: 'top' },
        },
        scales: {
          x: {
            type: 'linear',
            title: { display: true, text: xTitleText(xMode) },
            ticks: {
              callback: makeTickFormatter(xMode, displayTzOffsetMin),
            },
            grid: { drawOnChartArea: true },
          },
          ...yScales,
        },
      },
    });

    // ë‚´ë¶€ ìƒíƒœ ì €ì¥
    chartInstance._state = {
      xMode,
      dataArray: Array.isArray(myJSON) ? [...myJSON] : [],
      baseTsMs,
      displayTzOffsetMin,
    };

    // âœ… ResizeObserverë¡œ ì°¨íŠ¸ í¬ê¸° ìë™ ì¡°ì •
    const canvas = ctx instanceof HTMLCanvasElement ? ctx : document.getElementById(ctx);
    const container = canvas.parentElement;

    // canvasë¥¼ 100% ì±„ìš°ë„ë¡ ìŠ¤íƒ€ì¼ ì§€ì •
    Object.assign(canvas.style, {
      width: "100%",
      height: "100%",
      display: "block",
    });

    // ë¶€ëª¨ div í¬ê¸°ê°€ ë³€í•  ë•Œ canvasë„ ê°±ì‹ 
    if (container) {
      const resizeObserver = new ResizeObserver(() => {
        const { width, height } = container.getBoundingClientRect();
        canvas.width = width;
        canvas.height = height;
        chartInstance.resize(); // Chart.js ë‚´ë¶€ ë¦¬ì‚¬ì´ì¦ˆ ì²˜ë¦¬
      });
      resizeObserver.observe(container);

      // ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€: chartInstance íŒŒê´´ ì‹œ observer í•´ì œ
      chartInstance._resizeObserver = resizeObserver;
      const originalDestroy = chartInstance.destroy.bind(chartInstance);
      chartInstance.destroy = function () {
        resizeObserver.disconnect();
        originalDestroy();
      };
    }

    return chartInstance;
  }

  // --- 3. xì¶• ë‹¨ìœ„ ë²„íŠ¼ ì„¤ì • ---
  function setupXModeButtons() {
    const buttons = document.querySelectorAll(".xmode-btn");
    buttons.forEach((btn) => {
      btn.addEventListener("click", () => {
        const { currentChartData, chartOptionsState } = store.getState();
        const { currentXmode } = chartOptionsState;
        const newMode = btn.dataset.mode;
        // console.log("newMode: ", newMode);
        if (newMode === currentXmode) return;

        if (!currentChartData || currentChartData.length === 0) {
          console.warn("ì•„ì§ ì°¨íŠ¸ ë°ì´í„°ê°€ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.");
          showToast("ì•Œë¦¼", "ë°ì´í„°ë¥¼ ë¨¼ì € ë¶ˆëŸ¬ì˜¨ í›„ ë‹¨ìœ„ë¥¼ ë³€ê²½í•˜ì„¸ìš”.");
          return;
        }

        // active ìƒíƒœ ì „í™˜
        buttons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        
        store.dispatch({ type: 'UPDATE', target: 'chartOption_xmode', payload: newMode });
      });
    });
  }

  function reducer(state, action) {
    if (state === undefined) {
      return {
        directoryTree: {},
        macAddress: '',
        fileName: '',
        deviceConfig: {},
        currentChartData: [],
        chartOptionsState: { 
          tension: 0.2, 
          pointStyle: 'circle', 
          gridMode: 'both', 
          currentXmode: 's',
        },
        sseFlag: null,
      }
    }
    let newState;
    if (action.type === 'CREATE') {
      if (action.target === 'nav_dir') {
        newState = Object.assign({}, state, {
          directoryTree: { ...action.content },
        });
      } else if (action.target === 'main_section') {
        newState = Object.assign({}, state, {
          macAddress: action.deviceId,
          fileName: action.fileName,
          deviceConfig: { ...action.payload },
          sseFlag: action.sseFlag,
        });
      } else if (action.target === 'chart_section') {
        newState = Object.assign({}, state, {
          currentChartData: [ ...action.payload ]
        });
      }  
    } else if (action.type === 'UPDATE') {
      if (action.target === 'device_config') {
        newState = Object.assign({}, state, {
          deviceConfig: { ...action.payload },
        });
      } else if (action.target === 'chartOption_tension') {
        newState = Object.assign({}, state, {
          chartOptionsState: {
            ...state.chartOptionsState,
            tension: action.payload,
          }
        });
      } else if (action.target === 'chartOption_pointSel') {
        newState = Object.assign({}, state, {
          chartOptionsState: {
            ...state.chartOptionsState,
            pointStyle: action.payload,
          }
        });
      } else if (action.target === 'chartOption_gridSel') {
        newState = Object.assign({}, state, {
          chartOptionsState: {
            ...state.chartOptionsState,
            gridMode: action.payload,
          }
        });
      } else if (action.target === 'chartOption_xmode') {
        newState = Object.assign({}, state, {
          chartOptionsState: {
            ...state.chartOptionsState,
            currentXmode: action.payload,
          }
        });
      } 
    } else if (action.type === 'APPEND') {
      if (action.target === 'chart_section') {
        newState = Object.assign({}, state, {
          currentChartData: [ ...state.currentChartData, action.payload ]
        });
      }
    }
    return newState;
  }

  const productionURL = 'http://121.189.157.152:8080';
  const testURL = 'http://127.0.0.1:8080';
  let _URL = null;
  if (window.location.href.split('/')[2] === '127.0.0.1:8080') {
    _URL = testURL;
  } else {
    _URL = productionURL;
  }

  function updateAccordionCssOnClick(target) {
    // í´ë¦­í•œ ë¶€íŠ¸ìŠ¤íŠ¸ë© ì•„ì½”ë””ì–¸ ì»´í¬ë„ŒíŠ¸ì˜ cssë¥¼ ë³€ê²½
    const $btns = document.querySelectorAll('.accordion-button');
    $btns.forEach(btn => {
      const flag = (btn === target) && (btn.getAttribute('aria-expanded') === 'true')
      const background_color = flag ? '#EFF3FB' : 'transparent';
      const font_color = flag ? '#3B4ED9' : '#433D79';
      btn.style.backgroundColor = background_color;
      btn.style.color = font_color;
    });
  }

  function toggleAccordionButtonCss(target) {
    // í´ë¦­í•œ list-group-itemì—ì„œ ê°€ì¥ ê°€ê¹Œìš´(closest) accordion-button ìš”ì†Œë¥¼ ì°¾ì•„ cssë¥¼ ì¶”ê°€í•˜ë©°, ê·¸ ëŒ€ì‹  ë‹¤ë¥¸ accord-button ìš”ì†Œì˜ cssëŠ” ì´ˆê¸°í™”
    const $btns = document.querySelectorAll('.accordion-button');
    const $elem = target.closest('.accordion-item')?.querySelector('button');
    $btns.forEach(btn => {
      const flag = (btn === $elem)
      const background_color = flag ? '#EFF3FB' : 'transparent';
      const font_color = flag ? '#3B4ED9' : '#433D79';
      btn.style.backgroundColor = background_color;
      btn.style.color = font_color;
    });
  }

  const fetchDirectoryContents = async () => {
    const state = store.getState();
    const url = `${_URL}/scienceon/directoryAllContents/`;

    try {
      const response = await fetch(url, { method: 'GET' });
      if (!response.ok) {
        throw new Error(`Error: ${response.status}`);
      }
      if (response.status === 204) {
        console.log('No Content');
        return;
      }

      const res = await response.json();
      const directoryTree = res.paths.reduce((acc, path) => {
        const [dir, file] = path.split('/').filter(Boolean); // ['a', '1.csv'] í˜•íƒœ
        if (!file) return acc; // ë””ë ‰í„°ë¦¬ë§Œ ìˆëŠ” í•­ëª©('/a' ë“±)ì€ ê±´ë„ˆëœ€
        if (!acc[dir]) acc[dir] = [];
        acc[dir].push(file);
        return acc;
      }, {});

      store.dispatch({ type: 'CREATE', target: 'nav_dir', content: directoryTree });
      $('#accordionFlushExample').html(generateAccordionHTMLFromObject(directoryTree));
      const orig = document.getElementById("accordionFlushExample");
      const mobileContainer = document.getElementById("mobileAccordionContainer");
      if (orig && mobileContainer) {
        mobileContainer.innerHTML = orig.innerHTML;
      }

      $("#mobileAccordionContainer").on("click", "li.list-group-item", async function () {
        jsonFlag = false;

        // --- ğŸ”´ ê¸°ì¡´ SSE ì—°ê²° ì¢…ë£Œ ---
        if (currentEventSource) {
          console.log("ê¸°ì¡´ SSE ì—°ê²° ì¢…ë£Œ");
          currentEventSource.close();
          currentEventSource = null;
        }

        const macAddr_withColons = $(this).closest("div.accordion-item").find("button").text().trim();
        const fileName = $(this).text().trim().split('.').shift();
        $("ol.breadcrumb li").eq(0).text(macAddr_withColons);
        // $("ol.breadcrumb li").eq(1).text(fileName);
        const macAddr = removeColonsFromMac(macAddr_withColons);
        const sseFlag = macAddr === fileName;

        // ì„œë²„ì—ì„œ êµ¬ì„± ë¡œë“œ
        try {
          const url = `${_URL}/scienceon/get_iot_transmission_config/${encodeURIComponent(macAddr)}`;
          const response = await fetch(url, { method: 'GET' });
          const contentType = response.headers.get('content-type') || '';
          const isJson = contentType.includes('application/json');
          const payload = isJson ? await response.json() : await response.text();

          if (!response.ok) {
            const msg = isJson ? (payload?.error || payload?.message) : payload;
            throw new Error(msg || `ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
          }

          showToast('ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ', 'ì„œë²„ì—ì„œ ìµœì‹  êµ¬ì„±ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.', 'bg-success text-white');
          // ë°ì´í„° íŒŒì‹±(ì˜¤íƒ€ í˜¸í™˜ í¬í•¨)
          const data = payload || {};
          store.dispatch({ type: 'CREATE', target: 'main_section', deviceId: macAddr, fileName: fileName, payload: data, sseFlag: sseFlag });
          fetchIoTDataAndRenderTableAndLineChart();
        } catch (err) {
          console.error(err);
          showToast('ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨', err?.message || 'êµ¬ì„± ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'bg-danger text-white');
        }
      });
    } catch (error) {
      console.error('Error:', error);
    }
  };

  function cleanKey(k) {
    return (k || "").replace(/^\uFEFF/, "").trim();
  }

  // --- ë°ì´í„° ë¡œë“œ + í…Œì´ë¸”/ì°¨íŠ¸ ë Œë”ë§ ---
  async function fetchIoTDataAndRenderTableAndLineChart() {
    const { macAddress: macAddr, fileName, sseFlag, deviceConfig, chartOptionsState } = store.getState();
    if (!macAddr) return;
    
    try {
      // 1) ì´ˆê¸° ë°ì´í„° ë¡œë“œ
      const resp = await fetch(`${_URL}/scienceon/get_json_from_csv/${macAddr}?limit=${deviceConfig.chartWindow}&fileName=${fileName}`);
      const rows = await resp.json();
      if (!rows || rows.length === 0) return;

      // --- í…Œì´ë¸” í—¤ë” ë Œë”ë§ ---
      const rawKeys = Object.keys(rows[0]);
      keys = rawKeys.map(cleanKey);
      // console.log("keys: ", keys);

      document.querySelector("#thead").innerHTML =
        "<tr>" + keys.map(k => `<th>${k}</th>`).join('') + "</tr>";

      const tbody = document.querySelector("#tbody");
      tbody.innerHTML = "";

      rows.forEach(r => {
        const tr = document.createElement("tr");
        rawKeys.forEach((rawKey, idx) => {
          const td = document.createElement("td");
          const clean = keys[idx];          // cleanKey ì ìš©
          // td.textContent = r[rawKey] ?? ""; // r[rawKey]ì—ì„œ ê°’ ê°€ì ¸ì˜¤ê¸°

          let value = r[rawKey] ?? "";

          // ts ì»¬ëŸ¼ì¼ ê²½ìš° í¬ë§· ë³€í™˜
          if (clean.toLowerCase() === "ts") {
            value = formatTimestamp(value);
          }

          td.textContent = value;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });

      // --- ìŠ¤í¬ë¡¤ ì»¨í…Œì´ë„ˆ ì°¸ì¡° ---
      const scrollContainer = document.querySelector("#tbl").parentElement;

      // --- currentValue_section ì¹´ë“œ ë Œë”ë§ ---
      const currentValueSection = document.querySelector("#currentValue_section");
      currentValueSection.innerHTML = ""; // ì´ˆê¸°í™”

      const lastRow = rows[rows.length - 1];

      // --- ì„¼ì„œë³„ ì¹´ë“œ ìƒì„± ---
      rawKeys.forEach((rawKey, idx) => {
        const clean = keys[idx];
        if (clean.toLowerCase() === "ts") return; // ts ì œì™¸

        const value = lastRow[rawKey] ?? "";

        // ë‹¨ìœ„ ì¶”ì¶œ
        let unit = "";
        const unitMatch = clean.match(/\((.*?)\)/);
        if (unitMatch) unit = unitMatch[1];

        // --- ì¹´ë“œ ìƒì„± ---
        const card = document.createElement("div");
        card.className = "card mb-2";
        card.style.backgroundColor = colorMap[clean];

        const body = document.createElement("div");
        body.className = "card-body";

        // âœ… ì²´í¬ë°•ìŠ¤ ìƒì„±
        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.checked = true; // ê¸°ë³¸ ì²´í¬ ìƒíƒœ
        checkbox.style.marginRight = "8px";
        checkbox.dataset.sensor = clean;
        sensorSelection[clean] = true;

        // âœ… ì œëª© (ì„¼ì„œ ì´ë¦„)
        const title = document.createElement("h5");
        title.className = "card-title";
        title.textContent = clean;
        title.prepend(checkbox); // ì œëª© ì•ì— ì²´í¬ë°•ìŠ¤ ì‚½ì…

        // âœ… ê°’ í‘œì‹œ
        const text = document.createElement("p");
        text.className = "card-text fs-1 fw-bold text-light";
        text.textContent = `${value} ${unit}`;

        // ì¡°ë¦½
        body.appendChild(title);
        body.appendChild(text);
        card.appendChild(body);
        currentValueSection.appendChild(card);
      });

      // âœ… ì²´í¬ë°•ìŠ¤ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë“±ë¡
      currentValueSection.querySelectorAll('input[type="checkbox"]').forEach(chk => {
        chk.addEventListener('change', () => {
          const sensorName = chk.dataset.sensor;
          sensorSelection[sensorName] = chk.checked;

          // ìµœì†Œ 1ê°œ ì´ìƒ ì²´í¬ ìœ ì§€
          const checkedCount = Object.values(sensorSelection).filter(Boolean).length;
          createLineChartWithOptions();
        });
      });

      // // --- ì°¨íŠ¸ ì´ˆê¸° ë Œë”ë§ ---
      jsonFlag = true;
      // createLineChartWithOptions();
      store.dispatch({ type: 'CREATE', target: 'chart_section', payload: rows });

      if (!sseFlag) return;

      // --- âœ… ìƒˆë¡œìš´ SSE ì—°ê²° ìƒì„± ì „ì— í˜¹ì‹œ ë‚¨ì€ ì—°ê²° ë‹«ê¸° ---
      if (currentEventSource) {
        console.log("ê¸°ì¡´ SSE ì—°ê²° ì¬í™•ì¸ í›„ ì¢…ë£Œ");
        currentEventSource.close();
        currentEventSource = null;
      }

      // --- âœ… ìƒˆ SSE ì—°ê²° ì‹œì‘ ---
      currentEventSource = new EventSource(`${_URL}/scienceon/sse_stream/${macAddr}`);
      currentEventSource.addEventListener("ready", e => {
        console.log("SSE ready:", e.data);
      });

      currentEventSource.onmessage = e => {
        const rec = JSON.parse(e.data);
        // console.log("rec: ", rec);

        // --- 1. recì˜ key BOM ì œê±° ---
        const normalizedRec = {};
        Object.entries(rec).forEach(([k, v]) => {
          normalizedRec[cleanKey(k)] = v;
        });

        // --- 2. í…Œì´ë¸” í–‰ ì¶”ê°€ ---
        const tr = document.createElement("tr");
        keys.forEach(k => {
          const td = document.createElement("td");
          let value = normalizedRec[k] ?? "";

          // ts ì»¬ëŸ¼ í¬ë§· ë³€í™˜
          if (k.toLowerCase() === "ts") {
            value = formatTimestamp(value);
          }

          td.textContent = value;
          tr.appendChild(td);
        });
        tbody.appendChild(tr);

        // --- ë¶€ë“œëŸ½ê²Œ ìŠ¤í¬ë¡¤ ---
        scrollContainer.scrollTo({
          top: scrollContainer.scrollHeight,
          behavior: 'smooth'
        });

        // --- 3. currentValue_section ì¹´ë“œ ì—…ë°ì´íŠ¸ ---
        const currentValueSection = document.querySelector("#currentValue_section");
        const cards = currentValueSection.querySelectorAll(".card");

        keys.forEach((k, idx) => {
          if (k.toLowerCase() === "ts") return; // ts ì œì™¸

          const value = normalizedRec[k] ?? "";

          // ë‹¨ìœ„ ì¶”ì¶œ
          let unit = "";
          const unitMatch = k.match(/\((.*?)\)/);
          if (unitMatch) unit = unitMatch[1];

          // ì¹´ë“œì˜ card-text ê°±ì‹ 
          const card = cards[idx > 0 ? idx - 1 : idx]; // ts ì œì™¸í–ˆìœ¼ë¯€ë¡œ ì¸ë±ìŠ¤ ì¡°ì •
          if (card) {
            const textEl = card.querySelector(".card-text");
            if (textEl) {
              textEl.textContent = `${value} ${unit}`;
            }
          }
        });

        // --- ì°¨íŠ¸ ì—…ë°ì´íŠ¸ (ë‹¨ìˆœí™”) ---
        // chartInstance.appendRows([rec]);
        store.dispatch({ type: 'APPEND', target: 'chart_section', payload: normalizedRec });

      };
      currentEventSource.onerror = e => {
        console.warn("SSE error:", e);
      };
    } catch (err) {
      console.error(err);
    }
  }

  function createLineChartWithOptions() {
    const { macAddress: macAddr, fileName, sseFlag, deviceConfig, chartOptionsState, currentChartData } = store.getState();
    if (!macAddr || !jsonFlag) return;

    const { currentXmode: currentXMode } = chartOptionsState;
    // âœ… ìƒˆ ë‹¨ìœ„ì— ë§ê²Œ ì „ì²´ ë°ì´í„° ì¬ê³„ì‚°
    const { baseTsMs, series } = buildSeriesFromJSON(currentChartData, currentXMode);
    currentSeries = series;
    currentBaseTsMs = baseTsMs;

    // âœ… í˜„ì¬ ì²´í¬ë°•ìŠ¤ ìƒíƒœì— ë§ê²Œ í•„í„°ë§
    if (typeof sensorSelection === "object") {
      filteredSeries = Object.fromEntries(
        Object.entries(currentSeries).filter(([k]) => sensorSelection[k])
      );
    } else {
      filteredSeries = currentSeries;
    }

    // âœ… ì°¨íŠ¸ ì¬ìƒì„±
    chartInstance = createLineChart(
      document.getElementById("myChart"),
      filteredSeries,
      baseTsMs,
      currentChartData,
      currentXMode
    );

    // âœ… ê¸°ì¡´ ì„¤ì • ìœ ì§€ ì ìš©
    applyChartOptions();
  }

  const store = createStore(reducer, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
  window.store = store;
  store.subscribe(createLineChartWithOptions);

  window.onload = async function () {
    // í•„ë“œ ì°¸ì¡°
    const sendInterval = document.getElementById('sendInterval');
    const appendYes = document.getElementById('appendYes');
    const appendNo = document.getElementById('appendNo');
    const sendLimitMode = document.getElementById('sendLimitMode');
    const sendLimitCount = document.getElementById('sendLimitCount');
    const useEndAt = document.getElementById('useEndAt');
    const endAt = document.getElementById('endAt');
    const chartWindow = document.getElementById('chartWindow');
    const $list_group_items = document.querySelectorAll('li.list-group-item');

    $list_group_items.forEach(elem => {
      elem.addEventListener('click', (e) => {
        removeActiveClassFromListItems(e.target);
        toggleAccordionButtonCss(e.target);
        // store.dispatch({ type: 'MENU', menu: e.target.textContent });
      });
    });

    const $accordion_btns = document.querySelectorAll('.accordion-button');
    $accordion_btns.forEach(elem => {
      elem.style.boxShadow = 'none';
      elem.addEventListener('click', (e) => {
        updateAccordionCssOnClick(e.target);
      });
    });

    const $accordion_bodies = document.querySelectorAll('.accordion-body');
    const $lastElem = $accordion_bodies[$accordion_bodies.length - 1];
    if ($lastElem) {
      $lastElem.style.borderBottom = '0.5px solid #cecfd1';
    }

    $("#accordionFlushExample").on("click", "li.list-group-item", async function () {
      jsonFlag = false;

      // --- ğŸ”´ ê¸°ì¡´ SSE ì—°ê²° ì¢…ë£Œ ---
      if (currentEventSource) {
        console.log("ê¸°ì¡´ SSE ì—°ê²° ì¢…ë£Œ");
        currentEventSource.close();
        currentEventSource = null;
      }

      const macAddr_withColons = $(this).closest("div.accordion-item").find("button").text().trim();
      const fileName = $(this).text().trim().split('.').shift();
      $("ol.breadcrumb li").eq(0).text(macAddr_withColons);
      $("ol.breadcrumb li").eq(1).text(fileName);
      const macAddr = removeColonsFromMac(macAddr_withColons);
      const sseFlag = macAddr === fileName;

      // ì„œë²„ì—ì„œ êµ¬ì„± ë¡œë“œ
      try {
        const url = `${_URL}/scienceon/get_iot_transmission_config/${encodeURIComponent(macAddr)}`;
        const response = await fetch(url, { method: 'GET' });
        const contentType = response.headers.get('content-type') || '';
        const isJson = contentType.includes('application/json');
        const payload = isJson ? await response.json() : await response.text();

        if (!response.ok) {
          const msg = isJson ? (payload?.error || payload?.message) : payload;
          throw new Error(msg || `ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
        }

        showToast('ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì™„ë£Œ', 'ì„œë²„ì—ì„œ ìµœì‹  êµ¬ì„±ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.', 'bg-success text-white');
        const data = payload || {};
        store.dispatch({ type: 'CREATE', target: 'main_section', deviceId: macAddr, fileName: fileName, payload: data, sseFlag: sseFlag });
        fetchIoTDataAndRenderTableAndLineChart();
      } catch (err) {
        console.error(err);
        showToast('ì„¤ì • ë¶ˆëŸ¬ì˜¤ê¸° ì‹¤íŒ¨', err?.message || 'êµ¬ì„± ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'bg-danger text-white');
      }
    });

    const $toggleBtnWrap = document.getElementById('toggle-button');
    const $toggleBtn = document.getElementById('toggleBtn');
    const $nav = document.getElementById('nav');
    const $wrap = document.getElementById('wrap');
    const $btnIcon = document.getElementById('btnIcon');

    // ë²„íŠ¼ í´ë¦­ íŒì •ì€ ë²„íŠ¼ì— ì§ì ‘ ê±¸ì–´ë„ ë˜ê³ , wrapperì— ê±¸ì–´ë„ ë¨
    $toggleBtn.addEventListener('click', () => {
      // ì‚¬ì´ë“œë°”ë¥¼ ì ‘ê³  í‘¸ëŠ” í•µì‹¬ ë™ì‘
      $nav.classList.toggle('sideBar-hidden');

      // ë²„íŠ¼ ì•„ì´ì½˜ í† ê¸€ (ê¸°ì¡´ fa í´ë˜ìŠ¤ ì‚¬ìš©) â€” ì›í•˜ë©´ rotate í´ë˜ìŠ¤ ëŒ€ì‹  ì‚¬ìš© ê°€ëŠ¥
      if ($btnIcon.classList.contains('fa-caret-left')) {
        $btnIcon.classList.replace('fa-caret-left', 'fa-caret-right');
      } else {
        $btnIcon.classList.replace('fa-caret-right', 'fa-caret-left');
      }
    });

    fetchDirectoryContents();

    // system ëª¨ë‹¬ì°½ì˜ ì„¸ë¶€ í•­ëª©ì˜ ë‚´ìš© ì§€ì •í•˜ê¸°
    const systemModal = document.getElementById('dataConfigModal')
    if (systemModal) {
      systemModal.addEventListener('show.bs.modal', async event => {
        // í¬ì»¤ìŠ¤ë¥¼ ì²« ë²ˆì§¸ ì…ë ¥ ìš”ì†Œë¡œ ì´ë™
        const firstFocusable = systemModal.querySelector('input, textarea, button');
        if (firstFocusable) firstFocusable.focus();
        systemModal.setAttribute('aria-hidden', 'false');

        const button = event.relatedTarget;
        const modalTitle = systemModal.querySelector('.modal-title');
        if (modalTitle) {
          modalTitle.textContent = $("#macAddr").text().trim() + ' â€” Device Settings';
        }

        // ê¸°ì¡´ ìƒíƒœ ì´ˆê¸°í™”
        [sendInterval, sendLimitCount, endAt, chartWindow].forEach(el => {
          if (!el) return;
          el.setCustomValidity('');
          el.classList.remove('is-invalid', 'is-valid');
        });

        // ìœ í‹¸: datetime-local ì…ë ¥ê°’ìœ¼ë¡œ ë³€í™˜(YYYY-MM-DDTHH:MM)
        function isoToLocalInputValue(iso) {
          try {
            if (!iso) return '';
            const d = new Date(iso);
            if (Number.isNaN(d.getTime())) return '';
            const pad = n => String(n).padStart(2, '0');
            const yyyy = d.getFullYear();
            const mm = pad(d.getMonth() + 1);
            const dd = pad(d.getDate());
            const hh = pad(d.getHours());
            const mi = pad(d.getMinutes());
            return `${yyyy}-${mm}-${dd}T${hh}:${mi}`;
          } catch {
            return '';
          }
        }

        // ìœ í‹¸: ë¼ë””ì˜¤ ì„¸íŒ…
        function setAppendRadios(yesEl, noEl, val) {
          if (!yesEl || !noEl) return;
          const b = !!val;
          yesEl.checked = b;
          noEl.checked = !b;
        }

        // stateì—ì„œ êµ¬ì„± ë¡œë“œ
        const { macAddress: macAddr, deviceConfig: data } = store.getState();
        const si = data.sendInterval;
        const am = data.appendMode;
        const slo = data.sendLimitOn;
        const slc = data.sendLimitCount ?? null;
        const uea = data.useEndAt;
        const ea = data.endAt ?? null; // ISO8601 string expected
        const cw = data.chartWindow;

        if (sendInterval && si != null) sendInterval.value = si;
        setAppendRadios(appendYes, appendNo, am);

        if (sendLimitMode) {
          sendLimitMode.checked = !!slo;
        }
        if (sendLimitCount) {
          sendLimitCount.disabled = !sendLimitMode?.checked;
          if (sendLimitMode?.checked && slc != null) {
            sendLimitCount.value = slc;
          }
        }

        if (useEndAt) useEndAt.checked = !!uea;
        if (endAt) {
          endAt.disabled = !useEndAt?.checked;
          if (useEndAt?.checked && ea) {
            // datetime-localì„ ì‚¬ìš© ì¤‘ì´ë©´ ë¡œì»¬ ê°’ìœ¼ë¡œ ë³€í™˜
            const isDateTimeLocal = endAt.type === 'datetime-local';
            endAt.value = isDateTimeLocal ? isoToLocalInputValue(ea) : ea;
          }
        }

        if (chartWindow && cw != null) chartWindow.value = cw;
      });
    }

    $(function () {
      const $sendLimitMode = $('#sendLimitMode');
      const $sendLimitCount = $('#sendLimitCount');

      const $useEndAt = $('#useEndAt');
      const $endAt = $('#endAt');

      function syncSendLimit() {
        const enabled = $sendLimitMode.is(':checked');
        $sendLimitCount.prop('disabled', !enabled);
      }

      function syncEndAt() {
        const enabled = $useEndAt.is(':checked');
        $endAt.prop('disabled', !enabled);
      }

      // ì´ë²¤íŠ¸ ë°”ì¸ë”©
      $sendLimitMode.on('change', syncSendLimit);
      $useEndAt.on('change', syncEndAt);

      // ì´ˆê¸° ìƒíƒœ ë™ê¸°í™” (í¸ì§‘ í™”ë©´/ì¬ë°©ë¬¸ ë“±)
      syncSendLimit();
      syncEndAt();
    });

    // system ëª¨ë‹¬ì°½ì—ì„œ 'ì €ì¥'ë¥¼ í´ë¦­í–ˆì„ ì‹œ, ê¸°ê¸° ë° ì„œë²„ì˜ ì„¤ì •ë‚´ìš©ì„ ë°˜ì˜í•˜ê¸° ìœ„í•œ fetch ë° dispatch í˜¸ì¶œ.
    document.getElementById('dataConfigForm').addEventListener('submit', async event => {
      const { macAddress: macAddr } = store.getState();
      event.preventDefault();
      const form = event.currentTarget;

      // ê¸°ì¡´ ìƒíƒœ ì´ˆê¸°í™”
      [sendInterval, sendLimitCount, endAt, chartWindow].forEach(el => {
        if (!el) return;
        el.setCustomValidity('');
        el.classList.remove('is-invalid', 'is-valid');
      });

      const errors = [];

      // A. ë°ì´í„° ì „ì†¡ ê°„ê²©(ms): 2000 ì´ìƒ
      const si = Number(sendInterval.value);
      if (!Number.isFinite(si) || si < 2000) {
        sendInterval.setCustomValidity('2000ms ì´ìƒìœ¼ë¡œ ì…ë ¥í•˜ì„¸ìš”.');
        sendInterval.classList.add('is-invalid');
        errors.push('ë°ì´í„° ì „ì†¡ ê°„ê²©ì€ 2000ms ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤.');
      } else {
        sendInterval.classList.add('is-valid');
      }

      // B. ì´ì–´ì“°ê¸° ì—¬ë¶€(ë¼ë””ì˜¤)
      const appendSelected = appendYes.checked || appendNo.checked;
      if (!appendSelected) {
        errors.push('ì´ì–´ì“°ê¸°(append) ì—¬ë¶€ë¥¼ ì„ íƒí•˜ì„¸ìš”.');
      }

      // C. ì „ì†¡ íšŸìˆ˜ ì œí•œ
      if (sendLimitMode.checked) {
        sendLimitCount.disabled = false;
        const lc = Number(sendLimitCount.value);
        if (!Number.isInteger(lc) || lc < 1) {
          sendLimitCount.setCustomValidity('1 ì´ìƒì˜ ì •ìˆ˜ë¥¼ ì…ë ¥í•˜ì„¸ìš”.');
          sendLimitCount.classList.add('is-invalid');
          errors.push('ì „ì†¡ íšŸìˆ˜ ì œí•œì´ í™œì„±í™”ëœ ê²½ìš°, íšŸìˆ˜ëŠ” 1 ì´ìƒì˜ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');
        } else {
          sendLimitCount.classList.add('is-valid');
        }
      }

      // D. ë°ì´í„° ì „ì†¡ ì¢…ë£Œ ì‹œì : í˜„ì¬ ì‹œê° ì´í›„
      if (useEndAt.checked) {
        endAt.disabled = false;
        const val = endAt.value;
        const endDate = val ? new Date(val) : null;
        if (!endDate || isNaN(endDate.getTime()) || endDate <= new Date()) {
          endAt.setCustomValidity('í˜„ì¬ ì‹œê° ì´í›„ë¡œ ì„ íƒí•˜ì„¸ìš”.');
          endAt.classList.add('is-invalid');
          errors.push('ë°ì´í„° ì „ì†¡ ì¢…ë£Œ ì‹œì ì€ í˜„ì¬ ì‹œê° ì´í›„ì—¬ì•¼ í•©ë‹ˆë‹¤.');
        } else {
          endAt.classList.add('is-valid');
        }
      }

      // E. í‘œì‹œí•  ë°ì´í„° ê°œìˆ˜: 5~200 ì •ìˆ˜
      const cw = Number(chartWindow.value);
      if (!Number.isInteger(cw) || cw < 5 || cw > 200) {
        chartWindow.setCustomValidity('5~200 ì‚¬ì´ì˜ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”.');
        chartWindow.classList.add('is-invalid');
        errors.push('í‘œì‹œí•  ë°ì´í„° ê°œìˆ˜ëŠ” 5~200 ì‚¬ì´ì˜ ì •ìˆ˜ì—¬ì•¼ í•©ë‹ˆë‹¤.');
      } else {
        chartWindow.classList.add('is-valid');
      }

      // ê²°ê³¼ ì²˜ë¦¬
      if (errors.length > 0) {
        form.classList.add('was-validated');
        showToast(
          'ìœ íš¨ì„± ê²€ì‚¬ ì‹¤íŒ¨',
          errors.map(e => `â€¢ ${e}`).join('<br>'),
          'bg-danger text-white'
        );
        return;
      }

      // ê²€ì¦ ì„±ê³µ
      form.classList.remove('was-validated');
      console.log('ê²€ì¦ ì™„ë£Œ');

      // ì„œë²„ ì „ì†¡(fetch) ë¡œì§
      const submitBtn = document.querySelector('button[form="dataConfigForm"][type="submit"]');
      const prevBtnHtml = submitBtn ? submitBtn.innerHTML : null;
      if (submitBtn) {
        submitBtn.disabled = true;
        submitBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-2" role="status" aria-hidden="true"></span>ì €ì¥ ì¤‘...';
      }

      const params = new URLSearchParams();
      params.append('macAddr', macAddr);

      // ì•ì„œ ê²€ì¦ëœ ê°’ìœ¼ë¡œ ì „ì†¡ payload êµ¬ì„±
      const data = {
        sendInterval: si,
        appendMode: appendYes.checked ? true : false,
        sendLimitOn: sendLimitMode.checked,
        ...(sendLimitMode.checked ? { sendLimitCount: Number(sendLimitCount.value) } : {}),
        useEndAt: useEndAt.checked,
        ...(useEndAt.checked && endAt.value ? { endAt: new Date(endAt.value).toISOString() } : {}),
        chartWindow: cw
      };

      try {
        const url = `${_URL}/scienceon/update_iot_transmission_config/?${params.toString()}`;
        const response = await fetch(url, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(data)
        });

        // ì‘ë‹µ ì²˜ë¦¬
        const contentType = response.headers.get('content-type') || '';
        const isJson = contentType.includes('application/json');
        const payload = isJson ? await response.json() : await response.text();

        if (!response.ok) {
          const msg = isJson ? (payload?.error || payload?.message) : payload;
          throw new Error(msg || `ì„œë²„ ì˜¤ë¥˜: ${response.status}`);
        }

        // ì„±ê³µ í† ìŠ¤íŠ¸
        const successMsg = (isJson && payload?.message) ? payload.message : 'ì €ì¥ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.';
        showToast('ì €ì¥ ì™„ë£Œ', successMsg, 'bg-success text-white');

        // ëª¨ë‹¬ ë‹«ê¸° (Bootstrap 5)
        const modalEl = document.getElementById('dataConfigModal');
        if (window.bootstrap?.Modal) {
          const modal = bootstrap.Modal.getOrCreateInstance(modalEl);
          modal.hide();
        } else if (window.$) {
          $('#dataConfigModal').modal('hide');
        }

        store.dispatch({ type: 'UPDATE', target: 'device_config', payload: data });
      } catch (error) {
        console.error('Error:', error);
        showToast('ì˜¤ë¥˜ ë°œìƒ', (error && error.message) ? error.message : 'ìš”ì²­ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.', 'bg-danger text-white');
      } finally {
        if (submitBtn) {
          submitBtn.disabled = false;
          if (prevBtnHtml) submitBtn.innerHTML = prevBtnHtml;
        }
      }
    });

    const chartSection = document.getElementById("chart_section");
    const infoSection = document.getElementById("info_section");

    const tableSection = document.getElementById("table_section");
    const currentValueSection = document.getElementById("currentValue_section");

    /* ================================
       ğŸ”¸ ìˆ˜í‰ êµ¬ë¶„ì„  (chart / info ì‚¬ì´)
    ================================== */
    const verticalDivider = document.createElement("div");
    verticalDivider.id = "verticalDivider";
    Object.assign(verticalDivider.style, {
      position: "absolute",
      top: 0,
      bottom: 0,
      width: "6px",
      background: "rgba(0,0,0,0.0)",
      cursor: "col-resize",
      zIndex: 5,
      transition: "background 0.2s ease",
    });
    chartSection.parentElement.appendChild(verticalDivider);

    /* ================================
       ğŸ”¸ ìˆ˜ì§ êµ¬ë¶„ì„  (table / current ì‚¬ì´)
    ================================== */
    const horizontalDivider = document.createElement("div");
    horizontalDivider.id = "horizontalDivider";
    Object.assign(horizontalDivider.style, {
      height: "6px",
      background: "rgba(0,0,0,0.0)",
      cursor: "row-resize",
      transition: "background 0.2s ease",
    });
    tableSection.parentElement.insertBefore(horizontalDivider, currentValueSection);

    /* ================================
       ğŸ”¹ ìƒíƒœ ë³€ìˆ˜
    ================================== */
    let isDragging = false;
    let dragType = null;
    let startX = 0, startY = 0;
    let startChartFlex = 0, startInfoFlex = 0;
    let startTableFlex = 0, startCurrentFlex = 0;

    // ê°ë„ì™€ ë¶€ë“œëŸ¬ì›€ ì„¤ì •
    const sensitivity = 0.25; // ë§ˆìš°ìŠ¤ ì´ë™ ë°˜ì‘ ê°ë„ (ì‘ì„ìˆ˜ë¡ ë‘”ê°)
    const smoothness = 0.12;  // ë¶€ë“œëŸ¬ìš´ ì „í™˜ ì •ë„ (0~1 ì‚¬ì´ ê°’)

    // í˜„ì¬ ëª©í‘œ flex ê°’ì„ ì €ì¥ (ë³´ê°„ìš©)
    let targetChartFlex, targetInfoFlex, targetTableFlex, targetCurrentFlex;

    /* ================================
       ğŸ”¸ Divider ìœ„ì¹˜ ê°±ì‹ 
    ================================== */
    function updateDividerPositions() {
      const parentRect = chartSection.parentElement.getBoundingClientRect();
      const chartRect = chartSection.getBoundingClientRect();
      verticalDivider.style.left = `${chartRect.right - parentRect.left - 3}px`;
    }

    updateDividerPositions();
    window.addEventListener("resize", updateDividerPositions);

    /* ================================
       ğŸ”¸ ë¶€ë“œëŸ¬ìš´ ë³´ê°„ ì²˜ë¦¬
    ================================== */
    function lerp(current, target, factor) {
      return current + (target - current) * factor;
    }

    function animateFlex() {
      if (targetChartFlex !== undefined && targetInfoFlex !== undefined) {
        const cFlex = parseFloat(chartSection.style.flexGrow || getComputedStyle(chartSection).flexGrow);
        const iFlex = parseFloat(infoSection.style.flexGrow || getComputedStyle(infoSection).flexGrow);
        const newCFlex = lerp(cFlex, targetChartFlex, smoothness);
        const newIFlex = lerp(iFlex, targetInfoFlex, smoothness);
        chartSection.style.flex = newCFlex.toFixed(3);
        infoSection.style.flex = newIFlex.toFixed(3);
        updateDividerPositions();
      }

      if (targetTableFlex !== undefined && targetCurrentFlex !== undefined) {
        const tFlex = parseFloat(tableSection.style.flexGrow || getComputedStyle(tableSection).flexGrow);
        const cFlex = parseFloat(currentValueSection.style.flexGrow || getComputedStyle(currentValueSection).flexGrow);
        const newTFlex = lerp(tFlex, targetTableFlex, smoothness);
        const newCFlex = lerp(cFlex, targetCurrentFlex, smoothness);
        tableSection.style.flex = newTFlex.toFixed(3);
        currentValueSection.style.flex = newCFlex.toFixed(3);
      }

      requestAnimationFrame(animateFlex);
    }
    requestAnimationFrame(animateFlex);

    /* ================================
       ğŸ”¸ ë§ˆìš°ìŠ¤ ì´ë™ ì²˜ë¦¬
    ================================== */
    function onMouseMove(e) {
      if (!isDragging) return;

      if (dragType === "vertical") {
        const deltaX = (e.clientX - startX) * sensitivity;
        const newChartFlex = Math.max(1, startChartFlex + deltaX / 100);
        const newInfoFlex = Math.max(1, startInfoFlex - deltaX / 100);
        targetChartFlex = newChartFlex;
        targetInfoFlex = newInfoFlex;
      }

      if (dragType === "horizontal") {
        const deltaY = (e.clientY - startY) * sensitivity;
        const newTableFlex = Math.max(0.5, startTableFlex + deltaY / 100);
        const newCurrentFlex = Math.max(0.5, startCurrentFlex - deltaY / 100);
        targetTableFlex = newTableFlex;
        targetCurrentFlex = newCurrentFlex;
      }
    }

    function onMouseUp() {
      isDragging = false;
      dragType = null;
      document.body.style.userSelect = "";
      verticalDivider.style.background = "rgba(0,0,0,0.0)";
      horizontalDivider.style.background = "rgba(0,0,0,0.0)";
    }

    /* ================================
       ğŸ”¸ ë“œë˜ê·¸ ì‹œì‘ ì´ë²¤íŠ¸
    ================================== */
    verticalDivider.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragType = "vertical";
      startX = e.clientX;
      startChartFlex = parseFloat(getComputedStyle(chartSection).flexGrow);
      startInfoFlex = parseFloat(getComputedStyle(infoSection).flexGrow);
      document.body.style.userSelect = "none";
      verticalDivider.style.background = "rgba(0,0,0,0.3)";
    });

    horizontalDivider.addEventListener("mousedown", (e) => {
      isDragging = true;
      dragType = "horizontal";
      startY = e.clientY;
      startTableFlex = parseFloat(getComputedStyle(tableSection).flexGrow);
      startCurrentFlex = parseFloat(getComputedStyle(currentValueSection).flexGrow);
      document.body.style.userSelect = "none";
      horizontalDivider.style.background = "rgba(0,0,0,0.3)";
    });

    /* ================================
       ğŸ”¸ ì „ì—­ ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ ë“±ë¡
    ================================== */
    document.addEventListener("mousemove", onMouseMove);
    document.addEventListener("mouseup", onMouseUp);

    setupXModeButtons();
    setupChartOptionControls();
  }
</script>
{% endblock %}